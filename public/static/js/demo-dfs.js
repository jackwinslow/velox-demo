/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./demo-dfs/lib/main.js":
/*!******************************!*\
  !*** ./demo-dfs/lib/main.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var velox_songbird__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! velox-songbird */ \"./node_modules/velox-songbird/build/velox-bundle.js\");\n/* harmony import */ var velox_songbird__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(velox_songbird__WEBPACK_IMPORTED_MODULE_0__);\n\n\nconst files = new Map();\nconst file_callbacks = new Map();\nconst requested = new Map();\nconst peers = new Map();\nlet peer_target = 0;\nlet sr = false;\n\nlet velox_enabled = sessionStorage.getItem(\"ve\") ? sessionStorage.getItem(\"ve\") : \"false\"\n\nif (velox_enabled == \"true\") {\n    const v = new velox_songbird__WEBPACK_IMPORTED_MODULE_0__.Velox(\n        \"ws:139.144.30.74:80/nest\", \n        {\n            iceServers: [\n                {\n                    urls: [ \"stun:us-turn3.xirsys.com\" ]\n                }, \n                {\n                    username: \"7XSuZRhbYKu105TrkOEwcH2tPN-zWZDZw_72u2UQNZXq0FAQF8xjpFMP3eYERIicAAAAAGQPSt5wYXJsZW9u\",\n                    credential: \"8534c818-c1b9-11ed-987c-0242ac140004\",\n                    urls: [\n                        \"turn:us-turn3.xirsys.com:80?transport=udp\",\n                        //\"turn:us-turn3.xirsys.com:3478?transport=udp\",\n                        //\"turn:us-turn3.xirsys.com:80?transport=tcp\",\n                        //\"turn:us-turn3.xirsys.com:3478?transport=tcp\",\n                        //\"turns:us-turn3.xirsys.com:443?transport=tcp\",\n                        //\"turns:us-turn3.xirsys.com:5349?transport=tcp\"\n                    ]\n                }\n            ]\n        }\n    );\n\n    v.registerMessage(\"PC\", (m) => {\n            if (peer_target == 0) {\n                peer_target = Math.floor(m.Body/4)+1\n            }\n            if (peers.size >= peer_target && sr == false) {\n                sr == true\n                for (const k of file_callbacks.keys()) {    \n                    if (!files.has(k)) {\n                        const time_start = Date.now()\n                        requested.set(k)\n\n                        const reqing = [...peers.keys()][[Math.floor(Math.random() * peers.size)]]\n                        v.requestBlob(k, [reqing]).then((b) => {\n                            if (!files.has(k)) {\n                                console.log(\"injecting from peer:\", k, \"| Time:\", Date.now()-time_start)\n                                files.set(k, b)\n                                file_callbacks.get(k)()\n                                document.dispatchEvent(new CustomEvent('RU', {\n                                    detail: {\n                                        elapsed: Date.now()-time_start,\n                                        peer_fetched: true,\n                                        from: reqing\n                                    }\n                                }))\n                            }\n                        })\n                        setTimeout( async () => {\n                            if (!files.has(k)) {\n                                const response = await fetch(`http://139.144.30.74:8080/${k}`)\n                                const nb = await response.blob()\n                                const nf = new Blob([nb], {\n                                    type: nb.type,\n                                });\n                                files.set(k, nf)\n                                file_callbacks.get(k)()\n                                v.mountBlob(k, nf)\n                                console.log(\"injecting from server:\", k, \"| Time:\", Date.now()-time_start)\n                                document.dispatchEvent(new CustomEvent('RU', {\n                                    detail: {\n                                        elapsed: Date.now()-time_start,\n                                        peer_fetched: false,\n                                    }\n                                }))\n                            }\n                        }, 3500)\n\n                    }\n                }\n            }\n\n    })\n\n\n    document.addEventListener(\"DOMContentLoaded\", () => {\n\n        const toBlob = document.querySelectorAll(\"[data-src]\")\n            \n        for(var i = 0; i < toBlob.length; i++) {\n            const n = i\n            const path = toBlob[i].getAttribute(\"data-src\")\n            toBlob[n].removeAttribute(\"data-src\")\n            file_callbacks.set(path, () => {\n                const furl = URL.createObjectURL(files.get(path))\n                toBlob[n].setAttribute(\"src\", furl)\n            })\n        }\n\n        v.connect(\"image-demo\");\n\n        v.onchannelopen((peer) => {\n                console.log(\"opened connection to:\", peer)\n                peers.set(peer)\n                v.send({Type: \"PC\", Body:peers.size},[peer])\n            }\n        )\n\n        v.onchannelclose((peer) => {\n            console.log(\"closed connection to:\", peer)\n            peers.delete(peer)\n            }\n        )\n\n\n    }) \n\n} else {\n\n    document.addEventListener(\"DOMContentLoaded\", () => {\n\n        const toBlob = document.querySelectorAll(\"[data-src]\")\n            \n        for(var i = 0; i < toBlob.length; i++) {\n            const n = i\n            const path = toBlob[i].getAttribute(\"data-src\")\n            toBlob[n].removeAttribute(\"data-src\")\n            file_callbacks.set(path, () => {\n                const furl = URL.createObjectURL(files.get(path))\n                toBlob[n].setAttribute(\"src\", furl)\n            })\n        }\n    \n\n        for (const k of file_callbacks.keys()) {    \n            if (!files.has(k)) {\n                const time_start = Date.now()\n                setTimeout( async () => {\n                    if (!files.has(k)) {\n                        const response = await fetch(`http://139.144.30.74:8080/${k}`)\n                        const nb = await response.blob()\n                        const nf = new Blob([nb], {\n                            type: nb.type,\n                        });\n                        files.set(k, nf)\n                        file_callbacks.get(k)()\n                        v.mountBlob(k, nf)\n                        console.log(\"injecting from server:\", k, \"| Time:\", Date.now()-time_start)\n                        document.dispatchEvent(new CustomEvent('RU', {\n                            detail: {\n                                elapsed: Date.now()-time_start,\n                                peer_fetched: false,\n                            }\n                        }))\n                    }\n                }, 3500)\n            }\n        }\n    })\n}\n\n//# sourceURL=webpack://demo/./demo-dfs/lib/main.js?");

/***/ }),

/***/ "./node_modules/velox-songbird/build/velox-bundle.js":
/*!***********************************************************!*\
  !*** ./node_modules/velox-songbird/build/velox-bundle.js ***!
  \***********************************************************/
/***/ ((module) => {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(self, () => {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ \"./node_modules/spark-md5/spark-md5.js\":\n/*!*********************************************!*\\\n  !*** ./node_modules/spark-md5/spark-md5.js ***!\n  \\*********************************************/\n/***/ ((module) => {\n\n(function (factory) {\n    if (true) {\n        // Node/CommonJS\n        module.exports = factory();\n    } else { var glob; }\n}(function (undefined) {\n\n    'use strict';\n\n    /*\n     * Fastest md5 implementation around (JKM md5).\n     * Credits: Joseph Myers\n     *\n     * @see http://www.myersdaily.org/joseph/javascript/md5-text.html\n     * @see http://jsperf.com/md5-shootout/7\n     */\n\n    /* this function is much faster,\n      so if possible we use it. Some IEs\n      are the only ones I know of that\n      need the idiotic second function,\n      generated by an if clause.  */\n    var add32 = function (a, b) {\n        return (a + b) & 0xFFFFFFFF;\n    },\n        hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];\n\n\n    function cmn(q, a, b, x, s, t) {\n        a = add32(add32(a, q), add32(x, t));\n        return add32((a << s) | (a >>> (32 - s)), b);\n    }\n\n    function md5cycle(x, k) {\n        var a = x[0],\n            b = x[1],\n            c = x[2],\n            d = x[3];\n\n        a += (b & c | ~b & d) + k[0] - 680876936 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[1] - 389564586 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[2] + 606105819 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[3] - 1044525330 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n        a += (b & c | ~b & d) + k[4] - 176418897 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[5] + 1200080426 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[6] - 1473231341 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[7] - 45705983 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n        a += (b & c | ~b & d) + k[8] + 1770035416 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[9] - 1958414417 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[10] - 42063 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[11] - 1990404162 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n        a += (b & c | ~b & d) + k[12] + 1804603682 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[13] - 40341101 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[14] - 1502002290 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[15] + 1236535329 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n\n        a += (b & d | c & ~d) + k[1] - 165796510 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[6] - 1069501632 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[11] + 643717713 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[0] - 373897302 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n        a += (b & d | c & ~d) + k[5] - 701558691 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[10] + 38016083 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[15] - 660478335 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[4] - 405537848 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n        a += (b & d | c & ~d) + k[9] + 568446438 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[14] - 1019803690 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[3] - 187363961 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[8] + 1163531501 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n        a += (b & d | c & ~d) + k[13] - 1444681467 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[2] - 51403784 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[7] + 1735328473 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[12] - 1926607734 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n\n        a += (b ^ c ^ d) + k[5] - 378558 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[8] - 2022574463 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[11] + 1839030562 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[14] - 35309556 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n        a += (b ^ c ^ d) + k[1] - 1530992060 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[4] + 1272893353 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[7] - 155497632 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[10] - 1094730640 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n        a += (b ^ c ^ d) + k[13] + 681279174 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[0] - 358537222 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[3] - 722521979 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[6] + 76029189 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n        a += (b ^ c ^ d) + k[9] - 640364487 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[12] - 421815835 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[15] + 530742520 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[2] - 995338651 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n\n        a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;\n        b  = (b << 21 |b >>> 11) + c | 0;\n        a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;\n        b  = (b << 21 |b >>> 11) + c | 0;\n        a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;\n        b  = (b << 21 |b >>> 11) + c | 0;\n        a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;\n        b  = (b << 21 | b >>> 11) + c | 0;\n\n        x[0] = a + x[0] | 0;\n        x[1] = b + x[1] | 0;\n        x[2] = c + x[2] | 0;\n        x[3] = d + x[3] | 0;\n    }\n\n    function md5blk(s) {\n        var md5blks = [],\n            i; /* Andy King said do it this way. */\n\n        for (i = 0; i < 64; i += 4) {\n            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);\n        }\n        return md5blks;\n    }\n\n    function md5blk_array(a) {\n        var md5blks = [],\n            i; /* Andy King said do it this way. */\n\n        for (i = 0; i < 64; i += 4) {\n            md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);\n        }\n        return md5blks;\n    }\n\n    function md51(s) {\n        var n = s.length,\n            state = [1732584193, -271733879, -1732584194, 271733878],\n            i,\n            length,\n            tail,\n            tmp,\n            lo,\n            hi;\n\n        for (i = 64; i <= n; i += 64) {\n            md5cycle(state, md5blk(s.substring(i - 64, i)));\n        }\n        s = s.substring(i - 64);\n        length = s.length;\n        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);\n        }\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(state, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Beware that the final length might not fit in 32 bits so we take care of that\n        tmp = n * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n\n        md5cycle(state, tail);\n        return state;\n    }\n\n    function md51_array(a) {\n        var n = a.length,\n            state = [1732584193, -271733879, -1732584194, 271733878],\n            i,\n            length,\n            tail,\n            tmp,\n            lo,\n            hi;\n\n        for (i = 64; i <= n; i += 64) {\n            md5cycle(state, md5blk_array(a.subarray(i - 64, i)));\n        }\n\n        // Not sure if it is a bug, however IE10 will always produce a sub array of length 1\n        // containing the last element of the parent array if the sub array specified starts\n        // beyond the length of the parent array - weird.\n        // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue\n        a = (i - 64) < n ? a.subarray(i - 64) : new Uint8Array(0);\n\n        length = a.length;\n        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= a[i] << ((i % 4) << 3);\n        }\n\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(state, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Beware that the final length might not fit in 32 bits so we take care of that\n        tmp = n * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n\n        md5cycle(state, tail);\n\n        return state;\n    }\n\n    function rhex(n) {\n        var s = '',\n            j;\n        for (j = 0; j < 4; j += 1) {\n            s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];\n        }\n        return s;\n    }\n\n    function hex(x) {\n        var i;\n        for (i = 0; i < x.length; i += 1) {\n            x[i] = rhex(x[i]);\n        }\n        return x.join('');\n    }\n\n    // In some cases the fast add32 function cannot be used..\n    if (hex(md51('hello')) !== '5d41402abc4b2a76b9719d911017c592') {\n        add32 = function (x, y) {\n            var lsw = (x & 0xFFFF) + (y & 0xFFFF),\n                msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n            return (msw << 16) | (lsw & 0xFFFF);\n        };\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * ArrayBuffer slice polyfill.\n     *\n     * @see https://github.com/ttaubert/node-arraybuffer-slice\n     */\n\n    if (typeof ArrayBuffer !== 'undefined' && !ArrayBuffer.prototype.slice) {\n        (function () {\n            function clamp(val, length) {\n                val = (val | 0) || 0;\n\n                if (val < 0) {\n                    return Math.max(val + length, 0);\n                }\n\n                return Math.min(val, length);\n            }\n\n            ArrayBuffer.prototype.slice = function (from, to) {\n                var length = this.byteLength,\n                    begin = clamp(from, length),\n                    end = length,\n                    num,\n                    target,\n                    targetArray,\n                    sourceArray;\n\n                if (to !== undefined) {\n                    end = clamp(to, length);\n                }\n\n                if (begin > end) {\n                    return new ArrayBuffer(0);\n                }\n\n                num = end - begin;\n                target = new ArrayBuffer(num);\n                targetArray = new Uint8Array(target);\n\n                sourceArray = new Uint8Array(this, begin, num);\n                targetArray.set(sourceArray);\n\n                return target;\n            };\n        })();\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * Helpers.\n     */\n\n    function toUtf8(str) {\n        if (/[\\u0080-\\uFFFF]/.test(str)) {\n            str = unescape(encodeURIComponent(str));\n        }\n\n        return str;\n    }\n\n    function utf8Str2ArrayBuffer(str, returnUInt8Array) {\n        var length = str.length,\n           buff = new ArrayBuffer(length),\n           arr = new Uint8Array(buff),\n           i;\n\n        for (i = 0; i < length; i += 1) {\n            arr[i] = str.charCodeAt(i);\n        }\n\n        return returnUInt8Array ? arr : buff;\n    }\n\n    function arrayBuffer2Utf8Str(buff) {\n        return String.fromCharCode.apply(null, new Uint8Array(buff));\n    }\n\n    function concatenateArrayBuffers(first, second, returnUInt8Array) {\n        var result = new Uint8Array(first.byteLength + second.byteLength);\n\n        result.set(new Uint8Array(first));\n        result.set(new Uint8Array(second), first.byteLength);\n\n        return returnUInt8Array ? result : result.buffer;\n    }\n\n    function hexToBinaryString(hex) {\n        var bytes = [],\n            length = hex.length,\n            x;\n\n        for (x = 0; x < length - 1; x += 2) {\n            bytes.push(parseInt(hex.substr(x, 2), 16));\n        }\n\n        return String.fromCharCode.apply(String, bytes);\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * SparkMD5 OOP implementation.\n     *\n     * Use this class to perform an incremental md5, otherwise use the\n     * static methods instead.\n     */\n\n    function SparkMD5() {\n        // call reset to init the instance\n        this.reset();\n    }\n\n    /**\n     * Appends a string.\n     * A conversion will be applied if an utf8 string is detected.\n     *\n     * @param {String} str The string to be appended\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.append = function (str) {\n        // Converts the string to utf8 bytes if necessary\n        // Then append as binary\n        this.appendBinary(toUtf8(str));\n\n        return this;\n    };\n\n    /**\n     * Appends a binary string.\n     *\n     * @param {String} contents The binary string to be appended\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.appendBinary = function (contents) {\n        this._buff += contents;\n        this._length += contents.length;\n\n        var length = this._buff.length,\n            i;\n\n        for (i = 64; i <= length; i += 64) {\n            md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));\n        }\n\n        this._buff = this._buff.substring(i - 64);\n\n        return this;\n    };\n\n    /**\n     * Finishes the incremental computation, reseting the internal state and\n     * returning the result.\n     *\n     * @param {Boolean} raw True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.prototype.end = function (raw) {\n        var buff = this._buff,\n            length = buff.length,\n            i,\n            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            ret;\n\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= buff.charCodeAt(i) << ((i % 4) << 3);\n        }\n\n        this._finish(tail, length);\n        ret = hex(this._hash);\n\n        if (raw) {\n            ret = hexToBinaryString(ret);\n        }\n\n        this.reset();\n\n        return ret;\n    };\n\n    /**\n     * Resets the internal state of the computation.\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.reset = function () {\n        this._buff = '';\n        this._length = 0;\n        this._hash = [1732584193, -271733879, -1732584194, 271733878];\n\n        return this;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @return {Object} The state\n     */\n    SparkMD5.prototype.getState = function () {\n        return {\n            buff: this._buff,\n            length: this._length,\n            hash: this._hash.slice()\n        };\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @param {Object} state The state\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.setState = function (state) {\n        this._buff = state.buff;\n        this._length = state.length;\n        this._hash = state.hash;\n\n        return this;\n    };\n\n    /**\n     * Releases memory used by the incremental buffer and other additional\n     * resources. If you plan to use the instance again, use reset instead.\n     */\n    SparkMD5.prototype.destroy = function () {\n        delete this._hash;\n        delete this._buff;\n        delete this._length;\n    };\n\n    /**\n     * Finish the final calculation based on the tail.\n     *\n     * @param {Array}  tail   The tail (will be modified)\n     * @param {Number} length The length of the remaining buffer\n     */\n    SparkMD5.prototype._finish = function (tail, length) {\n        var i = length,\n            tmp,\n            lo,\n            hi;\n\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(this._hash, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Do the final computation based on the tail and length\n        // Beware that the final length may not fit in 32 bits so we take care of that\n        tmp = this._length * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n        md5cycle(this._hash, tail);\n    };\n\n    /**\n     * Performs the md5 hash on a string.\n     * A conversion will be applied if utf8 string is detected.\n     *\n     * @param {String}  str The string\n     * @param {Boolean} [raw] True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.hash = function (str, raw) {\n        // Converts the string to utf8 bytes if necessary\n        // Then compute it using the binary function\n        return SparkMD5.hashBinary(toUtf8(str), raw);\n    };\n\n    /**\n     * Performs the md5 hash on a binary string.\n     *\n     * @param {String}  content The binary string\n     * @param {Boolean} [raw]     True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.hashBinary = function (content, raw) {\n        var hash = md51(content),\n            ret = hex(hash);\n\n        return raw ? hexToBinaryString(ret) : ret;\n    };\n\n    // ---------------------------------------------------\n\n    /**\n     * SparkMD5 OOP implementation for array buffers.\n     *\n     * Use this class to perform an incremental md5 ONLY for array buffers.\n     */\n    SparkMD5.ArrayBuffer = function () {\n        // call reset to init the instance\n        this.reset();\n    };\n\n    /**\n     * Appends an array buffer.\n     *\n     * @param {ArrayBuffer} arr The array to be appended\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.append = function (arr) {\n        var buff = concatenateArrayBuffers(this._buff.buffer, arr, true),\n            length = buff.length,\n            i;\n\n        this._length += arr.byteLength;\n\n        for (i = 64; i <= length; i += 64) {\n            md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));\n        }\n\n        this._buff = (i - 64) < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);\n\n        return this;\n    };\n\n    /**\n     * Finishes the incremental computation, reseting the internal state and\n     * returning the result.\n     *\n     * @param {Boolean} raw True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.ArrayBuffer.prototype.end = function (raw) {\n        var buff = this._buff,\n            length = buff.length,\n            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            i,\n            ret;\n\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= buff[i] << ((i % 4) << 3);\n        }\n\n        this._finish(tail, length);\n        ret = hex(this._hash);\n\n        if (raw) {\n            ret = hexToBinaryString(ret);\n        }\n\n        this.reset();\n\n        return ret;\n    };\n\n    /**\n     * Resets the internal state of the computation.\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.reset = function () {\n        this._buff = new Uint8Array(0);\n        this._length = 0;\n        this._hash = [1732584193, -271733879, -1732584194, 271733878];\n\n        return this;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @return {Object} The state\n     */\n    SparkMD5.ArrayBuffer.prototype.getState = function () {\n        var state = SparkMD5.prototype.getState.call(this);\n\n        // Convert buffer to a string\n        state.buff = arrayBuffer2Utf8Str(state.buff);\n\n        return state;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @param {Object} state The state\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.setState = function (state) {\n        // Convert string to buffer\n        state.buff = utf8Str2ArrayBuffer(state.buff, true);\n\n        return SparkMD5.prototype.setState.call(this, state);\n    };\n\n    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;\n\n    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;\n\n    /**\n     * Performs the md5 hash on an array buffer.\n     *\n     * @param {ArrayBuffer} arr The array buffer\n     * @param {Boolean}     [raw] True to get the raw string, false to get the hex one\n     *\n     * @return {String} The result\n     */\n    SparkMD5.ArrayBuffer.hash = function (arr, raw) {\n        var hash = md51_array(new Uint8Array(arr)),\n            ret = hex(hash);\n\n        return raw ? hexToBinaryString(ret) : ret;\n    };\n\n    return SparkMD5;\n}));\n\n\n/***/ }),\n\n/***/ \"./lib/web/channel.ts\":\n/*!****************************!*\\\n  !*** ./lib/web/channel.ts ***!\n  \\****************************/\n/***/ ((__unused_webpack_module, exports, __nested_webpack_require_23482__) => {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Channel = void 0;\nconst interfaces_1 = __nested_webpack_require_23482__(/*! ./interfaces */ \"./lib/web/interfaces.ts\");\nconst velox_1 = __nested_webpack_require_23482__(/*! ./velox */ \"./lib/web/velox.ts\");\nclass Channel {\n    constructor(SNMHandler, RCMHandler, CMUHandler, MBHandler, BlobMount, RTCConfig) {\n        this._SCMQueue = [];\n        this._active = false;\n        this._SNMHandler = SNMHandler;\n        this._RCMHandler = RCMHandler;\n        this._CMUHandler = CMUHandler;\n        this._MBHandler = MBHandler;\n        this._BMAccess = BlobMount;\n        if (RTCConfig) {\n            this._peerConnection = new RTCPeerConnection(RTCConfig);\n        }\n        else {\n            this._peerConnection = new RTCPeerConnection({\n                iceServers: [\n                    {\n                        urls: \"stun:stun.1.google.com:19302\"\n                    }\n                ]\n            });\n        }\n    }\n    SCMProcessor(msg) {\n        const msgStr = JSON.stringify(msg);\n        const bytes = new TextEncoder().encode(msgStr);\n        const blob = new Blob([bytes], {\n            type: \"application/json;charset=utf-8\"\n        });\n        blob.arrayBuffer().then((blobData) => {\n            if (this._active) {\n                this._dataChannel.send(blobData);\n            }\n            else {\n                this._SCMQueue.push(msg);\n            }\n        });\n    }\n    RawMessage(ab) {\n        this._dataChannel.send(ab);\n    }\n    executeSCMQueue() {\n        while (this._SCMQueue.length > 0) {\n            this.SCMProcessor(this._SCMQueue.pop());\n        }\n    }\n    RNMProcessor(message) {\n        if (message.Type == interfaces_1.RecievableNestMessageType.StartHandshake) {\n            this._peerUUID = message.UUID;\n            this._dataChannel = this._peerConnection.createDataChannel(\"m\");\n            this._dataChannel.binaryType = \"arraybuffer\";\n            this._dataChannel.onmessage = (ev) => this._onmessageHandler(ev);\n            this._dataChannel.onopen = (ev) => this._onOpenHandler(ev);\n            this._dataChannel.onclose = (ev) => this._onCloseHandler(ev);\n            this._peerConnection.createOffer().then((offer) => {\n                this._peerConnection.setLocalDescription(offer);\n                const msg = {\n                    UUID: this._peerUUID,\n                    SDPOffer: offer,\n                    Type: interfaces_1.SendableNestMessageType.Offer\n                };\n                this._SNMHandler(msg);\n            });\n        }\n        else if (message.Type == interfaces_1.RecievableNestMessageType.Offer) {\n            this._peerUUID = message.UUID;\n            this._peerConnection.ondatachannel = (ev) => {\n                this._dataChannel = ev.channel;\n                this._dataChannel.binaryType = \"arraybuffer\";\n                this._dataChannel.onmessage = (ev) => this._onmessageHandler(ev);\n                this._dataChannel.onopen = (ev) => this._onOpenHandler(ev);\n                this._dataChannel.onclose = (ev) => this._onCloseHandler(ev);\n            };\n            this._peerConnection.setRemoteDescription(new RTCSessionDescription(message.SDPOffer));\n            this._peerConnection.createAnswer().then((answer) => {\n                this._peerConnection.setLocalDescription(answer);\n                const msg = {\n                    UUID: this._peerUUID,\n                    SDPOffer: answer,\n                    Type: interfaces_1.SendableNestMessageType.Answer\n                };\n                this._SNMHandler(msg);\n                this._peerConnection.onicecandidate = ({ candidate }) => {\n                    const msg = {\n                        UUID: this._peerUUID,\n                        Candidate: candidate,\n                        Type: interfaces_1.SendableNestMessageType.ICE\n                    };\n                    this._SNMHandler(msg);\n                };\n            });\n        }\n        else if (message.Type == interfaces_1.RecievableNestMessageType.Answer) {\n            this._peerConnection.setRemoteDescription(new RTCSessionDescription(message.SDPOffer));\n            this._peerConnection.onicecandidate = ({ candidate }) => {\n                const msg = {\n                    UUID: this._peerUUID,\n                    Candidate: candidate,\n                    Type: interfaces_1.SendableNestMessageType.ICE\n                };\n                this._SNMHandler(msg);\n            };\n        }\n        else if (message.Type == interfaces_1.RecievableNestMessageType.ICE) {\n            this._peerConnection.addIceCandidate(message.Candidate);\n        }\n        else {\n            console.log(\"default\");\n        }\n    }\n    _onOpenHandler(ev) {\n        this._active = true;\n        const meta_update = { Peer: this._peerUUID, Update: \"Opened\" };\n        this._CMUHandler(meta_update);\n        this.executeSCMQueue();\n    }\n    _onmessageHandler(ev) {\n        const h = (0, velox_1.hashAB)(ev.data);\n        if (!this._BMAccess.has(h)) {\n            this._BMAccess.set(h, ev.data);\n            this._MBHandler({ Hash: h });\n        }\n        try {\n            const jsonString = new TextDecoder().decode(ev.data);\n            const msg = JSON.parse(jsonString);\n            this._RCMHandler(Object.assign(Object.assign({}, msg), { UUID: this._peerUUID }));\n        }\n        catch (e) {\n        }\n    }\n    _onCloseHandler(ev) {\n        const meta_update = { Peer: this._peerUUID, Update: \"Closed\" };\n        this._CMUHandler(meta_update);\n    }\n}\nexports.Channel = Channel;\n\n\n/***/ }),\n\n/***/ \"./lib/web/interfaces.ts\":\n/*!*******************************!*\\\n  !*** ./lib/web/interfaces.ts ***!\n  \\*******************************/\n/***/ ((__unused_webpack_module, exports) => {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SendableNestMessageType = exports.RecievableNestMessageType = void 0;\nvar RecievableNestMessageType;\n(function (RecievableNestMessageType) {\n    RecievableNestMessageType[\"Initial\"] = \"IN\";\n    RecievableNestMessageType[\"StartHandshake\"] = \"SH\";\n    RecievableNestMessageType[\"Offer\"] = \"OF\";\n    RecievableNestMessageType[\"Answer\"] = \"AN\";\n    RecievableNestMessageType[\"ICE\"] = \"C\";\n})(RecievableNestMessageType = exports.RecievableNestMessageType || (exports.RecievableNestMessageType = {}));\nvar SendableNestMessageType;\n(function (SendableNestMessageType) {\n    SendableNestMessageType[\"Initial\"] = \"IN\";\n    SendableNestMessageType[\"Offer\"] = \"OF\";\n    SendableNestMessageType[\"Answer\"] = \"AN\";\n    SendableNestMessageType[\"ICE\"] = \"C\";\n})(SendableNestMessageType = exports.SendableNestMessageType || (exports.SendableNestMessageType = {}));\n\n\n/***/ }),\n\n/***/ \"./lib/web/nest.ts\":\n/*!*************************!*\\\n  !*** ./lib/web/nest.ts ***!\n  \\*************************/\n/***/ ((__unused_webpack_module, exports) => {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Nest = void 0;\nclass Nest {\n    constructor(sockAddr, RNMHandler) {\n        this._active = false;\n        this._sockAddr = \"ws:139.144.30.74:80/nest\";\n        if (sockAddr !== undefined) {\n            this._sockAddr = sockAddr;\n        }\n        this._ws = new WebSocket(this._sockAddr);\n        this._ws.onopen = () => {\n            this._active = true;\n            console.log(\"opened connection to nest\");\n        };\n        this._ws.onmessage = (event) => {\n            const message = JSON.parse(event.data);\n            RNMHandler(message);\n        };\n        this._ws.onclose = () => {\n            console.log(\"connection with the nest has been closed\");\n            this._active = false;\n        };\n        this._ws.onerror = (event) => {\n            console.log(event);\n            this._ws.close;\n        };\n    }\n    isActive() {\n        return this._active;\n    }\n    SNMProcessor(SNM) {\n        const dta = JSON.stringify(SNM);\n        this._ws.send(dta);\n    }\n}\nexports.Nest = Nest;\n\n\n/***/ }),\n\n/***/ \"./lib/web/velox.ts\":\n/*!**************************!*\\\n  !*** ./lib/web/velox.ts ***!\n  \\**************************/\n/***/ ((__unused_webpack_module, exports, __nested_webpack_require_31643__) => {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.hashAB = exports.Velox = void 0;\nconst channel_1 = __nested_webpack_require_31643__(/*! ./channel */ \"./lib/web/channel.ts\");\nconst nest_1 = __nested_webpack_require_31643__(/*! ./nest */ \"./lib/web/nest.ts\");\nconst interfaces_1 = __nested_webpack_require_31643__(/*! ./interfaces */ \"./lib/web/interfaces.ts\");\nconst SparkMD5 = __nested_webpack_require_31643__(/*! spark-md5 */ \"./node_modules/spark-md5/spark-md5.js\");\nclass Velox {\n    constructor(socketAddr, RTCConfig) {\n        this._beacon = new EventTarget();\n        this._mountedBlobs = new Map();\n        this._blobInfo = new Map();\n        this._blobRLookup = new Map();\n        this._onChannelOpened = (UUID) => console.log(UUID + \" Opened\");\n        this._onChannelClosed = (UUID) => console.log(UUID + \" Closed\");\n        this._activeChannels = new Map();\n        this._messageCallbackMap = new Map();\n        this._defaultMessageCallback = (cm) => { console.log(cm); };\n        const RCMHandler = (message) => {\n            this._beacon.dispatchEvent(new CustomEvent(\"RCM\", { detail: { CM: message } }));\n        };\n        const SNMHandler = (message) => {\n            this._beacon.dispatchEvent(new CustomEvent(\"SNM\", { detail: { SNM: message } }));\n        };\n        const RNMHandler = (message) => {\n            this._beacon.dispatchEvent(new CustomEvent(\"RNM\", { detail: { RNM: message } }));\n        };\n        const CMUHandler = (message) => {\n            this._beacon.dispatchEvent(new CustomEvent(\"CMU\", { detail: { CMU: message } }));\n        };\n        const MBHandler = (message) => {\n            this._beacon.dispatchEvent(new CustomEvent(\"MB\", { detail: { Hash: message.Hash } }));\n        };\n        this._beacon.addEventListener(\"MB\", (event) => {\n            const h = event.detail.Hash;\n            if (this._mountedBlobs.has(h) && this._blobInfo.has(h)) {\n                this._beacon.dispatchEvent(new CustomEvent(\"BMC\", { detail: { Id: this._blobInfo.get(h).Id, Type: this._blobInfo.get(h).Type, AB: this._mountedBlobs.get(h) } }));\n            }\n        });\n        this._beacon.addEventListener(\"RNM\", (event) => {\n            const message = event.detail.RNM;\n            if (message.Type == interfaces_1.RecievableNestMessageType.Initial) {\n                this._UUID = message.UUID;\n            }\n            else if (message.Type == interfaces_1.RecievableNestMessageType.StartHandshake || message.Type == interfaces_1.RecievableNestMessageType.Offer) {\n                this._activeChannels.set(message.UUID, new channel_1.Channel(SNMHandler, RCMHandler, CMUHandler, MBHandler, this._mountedBlobs, RTCConfig));\n                this._beacon.addEventListener(message.UUID, (event) => {\n                    this._activeChannels.get(message.UUID).RNMProcessor(event.detail.RNM);\n                });\n                this._beacon.dispatchEvent(new CustomEvent(message.UUID, { detail: { RNM: message } }));\n            }\n            else if (message.UUID != null) {\n                this._beacon.dispatchEvent(new CustomEvent(message.UUID, { detail: { RNM: message } }));\n            }\n        });\n        this._beacon.addEventListener(\"SNM\", (event) => {\n            const message = event.detail.SNM;\n            if (message.UUID == null) {\n                this._nest.SNMProcessor(Object.assign(Object.assign({}, message), { UUID: this._UUID }));\n            }\n            else {\n                this._nest.SNMProcessor(message);\n            }\n        });\n        this._beacon.addEventListener(\"RCM\", (event) => {\n            const message = event.detail.CM;\n            if (message.BlobRelay != undefined) {\n                if (message.BlobRelay == \"id\") {\n                    if (this._blobRLookup.has(message.Body)) {\n                        const h = this._blobRLookup.get(message.Body);\n                        this.send({ BlobRelay: \"h\",\n                            Body: {\n                                Hash: h, Info: this._blobInfo.get(h)\n                            }\n                        }, [message.UUID]);\n                        this.sendBlob(h, [message.UUID]);\n                    }\n                }\n                else if (message.BlobRelay == \"h\") {\n                    if (!this._blobInfo.has(message.Body.Hash)) {\n                        this._blobInfo.set(message.Body.Hash, message.Body.Info);\n                    }\n                    MBHandler({ Hash: message.Body.Hash });\n                }\n            }\n            else {\n                const f = this._messageCallbackMap.get(message.Type);\n                if (f == undefined) {\n                    this._defaultMessageCallback(message);\n                }\n                else {\n                    f(message);\n                }\n            }\n        });\n        this._beacon.addEventListener(\"CMU\", (event) => {\n            const message = event.detail.CMU;\n            if (message.Update == \"Opened\") {\n                this._onChannelOpened(message.Peer);\n            }\n            else if (message.Update == \"Closed\") {\n                this._onChannelClosed(message.Peer);\n            }\n        });\n        this._nest = new nest_1.Nest(socketAddr, RNMHandler);\n    }\n    connect(networkID) {\n        const message = { Type: interfaces_1.SendableNestMessageType.Initial, Other: networkID };\n        const x = setInterval(() => {\n            if (this._nest.isActive()) {\n                this._beacon.dispatchEvent(new CustomEvent(\"SNM\", { detail: { SNM: message } }));\n                clearInterval(x);\n            }\n        }, 10);\n    }\n    registerMessage(type, callback) {\n        this._messageCallbackMap.set(type, callback);\n    }\n    registerDefault(callback) {\n        this._defaultMessageCallback = callback;\n    }\n    onchannelopen(callback) {\n        this._onChannelOpened = callback;\n    }\n    onchannelclose(callback) {\n        this._onChannelClosed = callback;\n    }\n    send(cm, users) {\n        if (users == undefined || users.length == 0) {\n            for (const [key, channel] of this._activeChannels.entries()) {\n                channel.SCMProcessor(cm);\n            }\n        }\n        else {\n            for (const user of users) {\n                const channel = this._activeChannels.get(user);\n                channel.SCMProcessor(cm);\n            }\n        }\n    }\n    requestBlob(id, users) {\n        this.send({ BlobRelay: \"id\", Body: id }, users);\n        return new Promise((resolve) => {\n            this._beacon.addEventListener(\"BMC\", (event) => {\n                if (event.detail.Id == id) {\n                    const b = new Blob([event.detail.AB], { type: event.detail.Type });\n                    resolve(b);\n                    this.mountBlob(id, b);\n                }\n            });\n        });\n    }\n    mountBlob(id, blob) {\n        const type = blob.type;\n        blob.arrayBuffer().then((ab) => {\n            const hash = hashAB(ab);\n            this._blobInfo.set(hash, { Id: id, Type: type });\n            this._mountedBlobs.set(hash, ab);\n            this._blobRLookup.set(id, hash);\n        });\n    }\n    sendBlob(hash, users) {\n        if (this._mountedBlobs.has(hash)) {\n            const ab = this._mountedBlobs.get(hash);\n            if (users == undefined || users.length == 0) {\n                for (const [key, channel] of this._activeChannels.entries()) {\n                    channel.RawMessage(ab);\n                }\n            }\n            else {\n                for (const user of users) {\n                    const channel = this._activeChannels.get(user);\n                    channel.RawMessage(ab);\n                }\n            }\n        }\n    }\n}\nexports.Velox = Velox;\nfunction hashAB(ab) {\n    return SparkMD5.ArrayBuffer.hash(ab, true);\n}\nexports.hashAB = hashAB;\n\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_39641__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_39641__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \tvar __webpack_exports__ = __nested_webpack_require_39641__(\"./lib/web/velox.ts\");\n/******/ \t\n/******/ \treturn __webpack_exports__;\n/******/ })()\n;\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0Esb0VBQW9FLFVBQVUsZ0JBQWdCO0FBQzlGO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJCQUEyQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSw0REFBNEQseUJBQXlCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxvQkFBb0I7QUFDM0Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7Ozs7OztVQ3RMZDtVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBOzs7O1VFdEJBO1VBQ0E7VUFDQTtVQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vVmVsb3gvd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL1ZlbG94Ly4vbm9kZV9tb2R1bGVzL3NwYXJrLW1kNS9zcGFyay1tZDUuanMiLCJ3ZWJwYWNrOi8vVmVsb3gvLi9saWIvd2ViL2NoYW5uZWwudHMiLCJ3ZWJwYWNrOi8vVmVsb3gvLi9saWIvd2ViL2ludGVyZmFjZXMudHMiLCJ3ZWJwYWNrOi8vVmVsb3gvLi9saWIvd2ViL25lc3QudHMiLCJ3ZWJwYWNrOi8vVmVsb3gvLi9saWIvd2ViL3ZlbG94LnRzIiwid2VicGFjazovL1ZlbG94L3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL1ZlbG94L3dlYnBhY2svYmVmb3JlLXN0YXJ0dXAiLCJ3ZWJwYWNrOi8vVmVsb3gvd2VicGFjay9zdGFydHVwIiwid2VicGFjazovL1ZlbG94L3dlYnBhY2svYWZ0ZXItc3RhcnR1cCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJWZWxveFwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJWZWxveFwiXSA9IGZhY3RvcnkoKTtcbn0pKHNlbGYsICgpID0+IHtcbnJldHVybiAiLCIoZnVuY3Rpb24gKGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIE5vZGUvQ29tbW9uSlNcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgLy8gQU1EXG4gICAgICAgIGRlZmluZShmYWN0b3J5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBCcm93c2VyIGdsb2JhbHMgKHdpdGggc3VwcG9ydCBmb3Igd2ViIHdvcmtlcnMpXG4gICAgICAgIHZhciBnbG9iO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBnbG9iID0gd2luZG93O1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBnbG9iID0gc2VsZjtcbiAgICAgICAgfVxuXG4gICAgICAgIGdsb2IuU3BhcmtNRDUgPSBmYWN0b3J5KCk7XG4gICAgfVxufShmdW5jdGlvbiAodW5kZWZpbmVkKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICAvKlxuICAgICAqIEZhc3Rlc3QgbWQ1IGltcGxlbWVudGF0aW9uIGFyb3VuZCAoSktNIG1kNSkuXG4gICAgICogQ3JlZGl0czogSm9zZXBoIE15ZXJzXG4gICAgICpcbiAgICAgKiBAc2VlIGh0dHA6Ly93d3cubXllcnNkYWlseS5vcmcvam9zZXBoL2phdmFzY3JpcHQvbWQ1LXRleHQuaHRtbFxuICAgICAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vbWQ1LXNob290b3V0LzdcbiAgICAgKi9cblxuICAgIC8qIHRoaXMgZnVuY3Rpb24gaXMgbXVjaCBmYXN0ZXIsXG4gICAgICBzbyBpZiBwb3NzaWJsZSB3ZSB1c2UgaXQuIFNvbWUgSUVzXG4gICAgICBhcmUgdGhlIG9ubHkgb25lcyBJIGtub3cgb2YgdGhhdFxuICAgICAgbmVlZCB0aGUgaWRpb3RpYyBzZWNvbmQgZnVuY3Rpb24sXG4gICAgICBnZW5lcmF0ZWQgYnkgYW4gaWYgY2xhdXNlLiAgKi9cbiAgICB2YXIgYWRkMzIgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gKGEgKyBiKSAmIDB4RkZGRkZGRkY7XG4gICAgfSxcbiAgICAgICAgaGV4X2NociA9IFsnMCcsICcxJywgJzInLCAnMycsICc0JywgJzUnLCAnNicsICc3JywgJzgnLCAnOScsICdhJywgJ2InLCAnYycsICdkJywgJ2UnLCAnZiddO1xuXG5cbiAgICBmdW5jdGlvbiBjbW4ocSwgYSwgYiwgeCwgcywgdCkge1xuICAgICAgICBhID0gYWRkMzIoYWRkMzIoYSwgcSksIGFkZDMyKHgsIHQpKTtcbiAgICAgICAgcmV0dXJuIGFkZDMyKChhIDw8IHMpIHwgKGEgPj4+ICgzMiAtIHMpKSwgYik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWQ1Y3ljbGUoeCwgaykge1xuICAgICAgICB2YXIgYSA9IHhbMF0sXG4gICAgICAgICAgICBiID0geFsxXSxcbiAgICAgICAgICAgIGMgPSB4WzJdLFxuICAgICAgICAgICAgZCA9IHhbM107XG5cbiAgICAgICAgYSArPSAoYiAmIGMgfCB+YiAmIGQpICsga1swXSAtIDY4MDg3NjkzNiB8IDA7XG4gICAgICAgIGEgID0gKGEgPDwgNyB8IGEgPj4+IDI1KSArIGIgfCAwO1xuICAgICAgICBkICs9IChhICYgYiB8IH5hICYgYykgKyBrWzFdIC0gMzg5NTY0NTg2IHwgMDtcbiAgICAgICAgZCAgPSAoZCA8PCAxMiB8IGQgPj4+IDIwKSArIGEgfCAwO1xuICAgICAgICBjICs9IChkICYgYSB8IH5kICYgYikgKyBrWzJdICsgNjA2MTA1ODE5IHwgMDtcbiAgICAgICAgYyAgPSAoYyA8PCAxNyB8IGMgPj4+IDE1KSArIGQgfCAwO1xuICAgICAgICBiICs9IChjICYgZCB8IH5jICYgYSkgKyBrWzNdIC0gMTA0NDUyNTMzMCB8IDA7XG4gICAgICAgIGIgID0gKGIgPDwgMjIgfCBiID4+PiAxMCkgKyBjIHwgMDtcbiAgICAgICAgYSArPSAoYiAmIGMgfCB+YiAmIGQpICsga1s0XSAtIDE3NjQxODg5NyB8IDA7XG4gICAgICAgIGEgID0gKGEgPDwgNyB8IGEgPj4+IDI1KSArIGIgfCAwO1xuICAgICAgICBkICs9IChhICYgYiB8IH5hICYgYykgKyBrWzVdICsgMTIwMDA4MDQyNiB8IDA7XG4gICAgICAgIGQgID0gKGQgPDwgMTIgfCBkID4+PiAyMCkgKyBhIHwgMDtcbiAgICAgICAgYyArPSAoZCAmIGEgfCB+ZCAmIGIpICsga1s2XSAtIDE0NzMyMzEzNDEgfCAwO1xuICAgICAgICBjICA9IChjIDw8IDE3IHwgYyA+Pj4gMTUpICsgZCB8IDA7XG4gICAgICAgIGIgKz0gKGMgJiBkIHwgfmMgJiBhKSArIGtbN10gLSA0NTcwNTk4MyB8IDA7XG4gICAgICAgIGIgID0gKGIgPDwgMjIgfCBiID4+PiAxMCkgKyBjIHwgMDtcbiAgICAgICAgYSArPSAoYiAmIGMgfCB+YiAmIGQpICsga1s4XSArIDE3NzAwMzU0MTYgfCAwO1xuICAgICAgICBhICA9IChhIDw8IDcgfCBhID4+PiAyNSkgKyBiIHwgMDtcbiAgICAgICAgZCArPSAoYSAmIGIgfCB+YSAmIGMpICsga1s5XSAtIDE5NTg0MTQ0MTcgfCAwO1xuICAgICAgICBkICA9IChkIDw8IDEyIHwgZCA+Pj4gMjApICsgYSB8IDA7XG4gICAgICAgIGMgKz0gKGQgJiBhIHwgfmQgJiBiKSArIGtbMTBdIC0gNDIwNjMgfCAwO1xuICAgICAgICBjICA9IChjIDw8IDE3IHwgYyA+Pj4gMTUpICsgZCB8IDA7XG4gICAgICAgIGIgKz0gKGMgJiBkIHwgfmMgJiBhKSArIGtbMTFdIC0gMTk5MDQwNDE2MiB8IDA7XG4gICAgICAgIGIgID0gKGIgPDwgMjIgfCBiID4+PiAxMCkgKyBjIHwgMDtcbiAgICAgICAgYSArPSAoYiAmIGMgfCB+YiAmIGQpICsga1sxMl0gKyAxODA0NjAzNjgyIHwgMDtcbiAgICAgICAgYSAgPSAoYSA8PCA3IHwgYSA+Pj4gMjUpICsgYiB8IDA7XG4gICAgICAgIGQgKz0gKGEgJiBiIHwgfmEgJiBjKSArIGtbMTNdIC0gNDAzNDExMDEgfCAwO1xuICAgICAgICBkICA9IChkIDw8IDEyIHwgZCA+Pj4gMjApICsgYSB8IDA7XG4gICAgICAgIGMgKz0gKGQgJiBhIHwgfmQgJiBiKSArIGtbMTRdIC0gMTUwMjAwMjI5MCB8IDA7XG4gICAgICAgIGMgID0gKGMgPDwgMTcgfCBjID4+PiAxNSkgKyBkIHwgMDtcbiAgICAgICAgYiArPSAoYyAmIGQgfCB+YyAmIGEpICsga1sxNV0gKyAxMjM2NTM1MzI5IHwgMDtcbiAgICAgICAgYiAgPSAoYiA8PCAyMiB8IGIgPj4+IDEwKSArIGMgfCAwO1xuXG4gICAgICAgIGEgKz0gKGIgJiBkIHwgYyAmIH5kKSArIGtbMV0gLSAxNjU3OTY1MTAgfCAwO1xuICAgICAgICBhICA9IChhIDw8IDUgfCBhID4+PiAyNykgKyBiIHwgMDtcbiAgICAgICAgZCArPSAoYSAmIGMgfCBiICYgfmMpICsga1s2XSAtIDEwNjk1MDE2MzIgfCAwO1xuICAgICAgICBkICA9IChkIDw8IDkgfCBkID4+PiAyMykgKyBhIHwgMDtcbiAgICAgICAgYyArPSAoZCAmIGIgfCBhICYgfmIpICsga1sxMV0gKyA2NDM3MTc3MTMgfCAwO1xuICAgICAgICBjICA9IChjIDw8IDE0IHwgYyA+Pj4gMTgpICsgZCB8IDA7XG4gICAgICAgIGIgKz0gKGMgJiBhIHwgZCAmIH5hKSArIGtbMF0gLSAzNzM4OTczMDIgfCAwO1xuICAgICAgICBiICA9IChiIDw8IDIwIHwgYiA+Pj4gMTIpICsgYyB8IDA7XG4gICAgICAgIGEgKz0gKGIgJiBkIHwgYyAmIH5kKSArIGtbNV0gLSA3MDE1NTg2OTEgfCAwO1xuICAgICAgICBhICA9IChhIDw8IDUgfCBhID4+PiAyNykgKyBiIHwgMDtcbiAgICAgICAgZCArPSAoYSAmIGMgfCBiICYgfmMpICsga1sxMF0gKyAzODAxNjA4MyB8IDA7XG4gICAgICAgIGQgID0gKGQgPDwgOSB8IGQgPj4+IDIzKSArIGEgfCAwO1xuICAgICAgICBjICs9IChkICYgYiB8IGEgJiB+YikgKyBrWzE1XSAtIDY2MDQ3ODMzNSB8IDA7XG4gICAgICAgIGMgID0gKGMgPDwgMTQgfCBjID4+PiAxOCkgKyBkIHwgMDtcbiAgICAgICAgYiArPSAoYyAmIGEgfCBkICYgfmEpICsga1s0XSAtIDQwNTUzNzg0OCB8IDA7XG4gICAgICAgIGIgID0gKGIgPDwgMjAgfCBiID4+PiAxMikgKyBjIHwgMDtcbiAgICAgICAgYSArPSAoYiAmIGQgfCBjICYgfmQpICsga1s5XSArIDU2ODQ0NjQzOCB8IDA7XG4gICAgICAgIGEgID0gKGEgPDwgNSB8IGEgPj4+IDI3KSArIGIgfCAwO1xuICAgICAgICBkICs9IChhICYgYyB8IGIgJiB+YykgKyBrWzE0XSAtIDEwMTk4MDM2OTAgfCAwO1xuICAgICAgICBkICA9IChkIDw8IDkgfCBkID4+PiAyMykgKyBhIHwgMDtcbiAgICAgICAgYyArPSAoZCAmIGIgfCBhICYgfmIpICsga1szXSAtIDE4NzM2Mzk2MSB8IDA7XG4gICAgICAgIGMgID0gKGMgPDwgMTQgfCBjID4+PiAxOCkgKyBkIHwgMDtcbiAgICAgICAgYiArPSAoYyAmIGEgfCBkICYgfmEpICsga1s4XSArIDExNjM1MzE1MDEgfCAwO1xuICAgICAgICBiICA9IChiIDw8IDIwIHwgYiA+Pj4gMTIpICsgYyB8IDA7XG4gICAgICAgIGEgKz0gKGIgJiBkIHwgYyAmIH5kKSArIGtbMTNdIC0gMTQ0NDY4MTQ2NyB8IDA7XG4gICAgICAgIGEgID0gKGEgPDwgNSB8IGEgPj4+IDI3KSArIGIgfCAwO1xuICAgICAgICBkICs9IChhICYgYyB8IGIgJiB+YykgKyBrWzJdIC0gNTE0MDM3ODQgfCAwO1xuICAgICAgICBkICA9IChkIDw8IDkgfCBkID4+PiAyMykgKyBhIHwgMDtcbiAgICAgICAgYyArPSAoZCAmIGIgfCBhICYgfmIpICsga1s3XSArIDE3MzUzMjg0NzMgfCAwO1xuICAgICAgICBjICA9IChjIDw8IDE0IHwgYyA+Pj4gMTgpICsgZCB8IDA7XG4gICAgICAgIGIgKz0gKGMgJiBhIHwgZCAmIH5hKSArIGtbMTJdIC0gMTkyNjYwNzczNCB8IDA7XG4gICAgICAgIGIgID0gKGIgPDwgMjAgfCBiID4+PiAxMikgKyBjIHwgMDtcblxuICAgICAgICBhICs9IChiIF4gYyBeIGQpICsga1s1XSAtIDM3ODU1OCB8IDA7XG4gICAgICAgIGEgID0gKGEgPDwgNCB8IGEgPj4+IDI4KSArIGIgfCAwO1xuICAgICAgICBkICs9IChhIF4gYiBeIGMpICsga1s4XSAtIDIwMjI1NzQ0NjMgfCAwO1xuICAgICAgICBkICA9IChkIDw8IDExIHwgZCA+Pj4gMjEpICsgYSB8IDA7XG4gICAgICAgIGMgKz0gKGQgXiBhIF4gYikgKyBrWzExXSArIDE4MzkwMzA1NjIgfCAwO1xuICAgICAgICBjICA9IChjIDw8IDE2IHwgYyA+Pj4gMTYpICsgZCB8IDA7XG4gICAgICAgIGIgKz0gKGMgXiBkIF4gYSkgKyBrWzE0XSAtIDM1MzA5NTU2IHwgMDtcbiAgICAgICAgYiAgPSAoYiA8PCAyMyB8IGIgPj4+IDkpICsgYyB8IDA7XG4gICAgICAgIGEgKz0gKGIgXiBjIF4gZCkgKyBrWzFdIC0gMTUzMDk5MjA2MCB8IDA7XG4gICAgICAgIGEgID0gKGEgPDwgNCB8IGEgPj4+IDI4KSArIGIgfCAwO1xuICAgICAgICBkICs9IChhIF4gYiBeIGMpICsga1s0XSArIDEyNzI4OTMzNTMgfCAwO1xuICAgICAgICBkICA9IChkIDw8IDExIHwgZCA+Pj4gMjEpICsgYSB8IDA7XG4gICAgICAgIGMgKz0gKGQgXiBhIF4gYikgKyBrWzddIC0gMTU1NDk3NjMyIHwgMDtcbiAgICAgICAgYyAgPSAoYyA8PCAxNiB8IGMgPj4+IDE2KSArIGQgfCAwO1xuICAgICAgICBiICs9IChjIF4gZCBeIGEpICsga1sxMF0gLSAxMDk0NzMwNjQwIHwgMDtcbiAgICAgICAgYiAgPSAoYiA8PCAyMyB8IGIgPj4+IDkpICsgYyB8IDA7XG4gICAgICAgIGEgKz0gKGIgXiBjIF4gZCkgKyBrWzEzXSArIDY4MTI3OTE3NCB8IDA7XG4gICAgICAgIGEgID0gKGEgPDwgNCB8IGEgPj4+IDI4KSArIGIgfCAwO1xuICAgICAgICBkICs9IChhIF4gYiBeIGMpICsga1swXSAtIDM1ODUzNzIyMiB8IDA7XG4gICAgICAgIGQgID0gKGQgPDwgMTEgfCBkID4+PiAyMSkgKyBhIHwgMDtcbiAgICAgICAgYyArPSAoZCBeIGEgXiBiKSArIGtbM10gLSA3MjI1MjE5NzkgfCAwO1xuICAgICAgICBjICA9IChjIDw8IDE2IHwgYyA+Pj4gMTYpICsgZCB8IDA7XG4gICAgICAgIGIgKz0gKGMgXiBkIF4gYSkgKyBrWzZdICsgNzYwMjkxODkgfCAwO1xuICAgICAgICBiICA9IChiIDw8IDIzIHwgYiA+Pj4gOSkgKyBjIHwgMDtcbiAgICAgICAgYSArPSAoYiBeIGMgXiBkKSArIGtbOV0gLSA2NDAzNjQ0ODcgfCAwO1xuICAgICAgICBhICA9IChhIDw8IDQgfCBhID4+PiAyOCkgKyBiIHwgMDtcbiAgICAgICAgZCArPSAoYSBeIGIgXiBjKSArIGtbMTJdIC0gNDIxODE1ODM1IHwgMDtcbiAgICAgICAgZCAgPSAoZCA8PCAxMSB8IGQgPj4+IDIxKSArIGEgfCAwO1xuICAgICAgICBjICs9IChkIF4gYSBeIGIpICsga1sxNV0gKyA1MzA3NDI1MjAgfCAwO1xuICAgICAgICBjICA9IChjIDw8IDE2IHwgYyA+Pj4gMTYpICsgZCB8IDA7XG4gICAgICAgIGIgKz0gKGMgXiBkIF4gYSkgKyBrWzJdIC0gOTk1MzM4NjUxIHwgMDtcbiAgICAgICAgYiAgPSAoYiA8PCAyMyB8IGIgPj4+IDkpICsgYyB8IDA7XG5cbiAgICAgICAgYSArPSAoYyBeIChiIHwgfmQpKSArIGtbMF0gLSAxOTg2MzA4NDQgfCAwO1xuICAgICAgICBhICA9IChhIDw8IDYgfCBhID4+PiAyNikgKyBiIHwgMDtcbiAgICAgICAgZCArPSAoYiBeIChhIHwgfmMpKSArIGtbN10gKyAxMTI2ODkxNDE1IHwgMDtcbiAgICAgICAgZCAgPSAoZCA8PCAxMCB8IGQgPj4+IDIyKSArIGEgfCAwO1xuICAgICAgICBjICs9IChhIF4gKGQgfCB+YikpICsga1sxNF0gLSAxNDE2MzU0OTA1IHwgMDtcbiAgICAgICAgYyAgPSAoYyA8PCAxNSB8IGMgPj4+IDE3KSArIGQgfCAwO1xuICAgICAgICBiICs9IChkIF4gKGMgfCB+YSkpICsga1s1XSAtIDU3NDM0MDU1IHwgMDtcbiAgICAgICAgYiAgPSAoYiA8PCAyMSB8YiA+Pj4gMTEpICsgYyB8IDA7XG4gICAgICAgIGEgKz0gKGMgXiAoYiB8IH5kKSkgKyBrWzEyXSArIDE3MDA0ODU1NzEgfCAwO1xuICAgICAgICBhICA9IChhIDw8IDYgfCBhID4+PiAyNikgKyBiIHwgMDtcbiAgICAgICAgZCArPSAoYiBeIChhIHwgfmMpKSArIGtbM10gLSAxODk0OTg2NjA2IHwgMDtcbiAgICAgICAgZCAgPSAoZCA8PCAxMCB8IGQgPj4+IDIyKSArIGEgfCAwO1xuICAgICAgICBjICs9IChhIF4gKGQgfCB+YikpICsga1sxMF0gLSAxMDUxNTIzIHwgMDtcbiAgICAgICAgYyAgPSAoYyA8PCAxNSB8IGMgPj4+IDE3KSArIGQgfCAwO1xuICAgICAgICBiICs9IChkIF4gKGMgfCB+YSkpICsga1sxXSAtIDIwNTQ5MjI3OTkgfCAwO1xuICAgICAgICBiICA9IChiIDw8IDIxIHxiID4+PiAxMSkgKyBjIHwgMDtcbiAgICAgICAgYSArPSAoYyBeIChiIHwgfmQpKSArIGtbOF0gKyAxODczMzEzMzU5IHwgMDtcbiAgICAgICAgYSAgPSAoYSA8PCA2IHwgYSA+Pj4gMjYpICsgYiB8IDA7XG4gICAgICAgIGQgKz0gKGIgXiAoYSB8IH5jKSkgKyBrWzE1XSAtIDMwNjExNzQ0IHwgMDtcbiAgICAgICAgZCAgPSAoZCA8PCAxMCB8IGQgPj4+IDIyKSArIGEgfCAwO1xuICAgICAgICBjICs9IChhIF4gKGQgfCB+YikpICsga1s2XSAtIDE1NjAxOTgzODAgfCAwO1xuICAgICAgICBjICA9IChjIDw8IDE1IHwgYyA+Pj4gMTcpICsgZCB8IDA7XG4gICAgICAgIGIgKz0gKGQgXiAoYyB8IH5hKSkgKyBrWzEzXSArIDEzMDkxNTE2NDkgfCAwO1xuICAgICAgICBiICA9IChiIDw8IDIxIHxiID4+PiAxMSkgKyBjIHwgMDtcbiAgICAgICAgYSArPSAoYyBeIChiIHwgfmQpKSArIGtbNF0gLSAxNDU1MjMwNzAgfCAwO1xuICAgICAgICBhICA9IChhIDw8IDYgfCBhID4+PiAyNikgKyBiIHwgMDtcbiAgICAgICAgZCArPSAoYiBeIChhIHwgfmMpKSArIGtbMTFdIC0gMTEyMDIxMDM3OSB8IDA7XG4gICAgICAgIGQgID0gKGQgPDwgMTAgfCBkID4+PiAyMikgKyBhIHwgMDtcbiAgICAgICAgYyArPSAoYSBeIChkIHwgfmIpKSArIGtbMl0gKyA3MTg3ODcyNTkgfCAwO1xuICAgICAgICBjICA9IChjIDw8IDE1IHwgYyA+Pj4gMTcpICsgZCB8IDA7XG4gICAgICAgIGIgKz0gKGQgXiAoYyB8IH5hKSkgKyBrWzldIC0gMzQzNDg1NTUxIHwgMDtcbiAgICAgICAgYiAgPSAoYiA8PCAyMSB8IGIgPj4+IDExKSArIGMgfCAwO1xuXG4gICAgICAgIHhbMF0gPSBhICsgeFswXSB8IDA7XG4gICAgICAgIHhbMV0gPSBiICsgeFsxXSB8IDA7XG4gICAgICAgIHhbMl0gPSBjICsgeFsyXSB8IDA7XG4gICAgICAgIHhbM10gPSBkICsgeFszXSB8IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWQ1YmxrKHMpIHtcbiAgICAgICAgdmFyIG1kNWJsa3MgPSBbXSxcbiAgICAgICAgICAgIGk7IC8qIEFuZHkgS2luZyBzYWlkIGRvIGl0IHRoaXMgd2F5LiAqL1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA2NDsgaSArPSA0KSB7XG4gICAgICAgICAgICBtZDVibGtzW2kgPj4gMl0gPSBzLmNoYXJDb2RlQXQoaSkgKyAocy5jaGFyQ29kZUF0KGkgKyAxKSA8PCA4KSArIChzLmNoYXJDb2RlQXQoaSArIDIpIDw8IDE2KSArIChzLmNoYXJDb2RlQXQoaSArIDMpIDw8IDI0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWQ1YmxrcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZDVibGtfYXJyYXkoYSkge1xuICAgICAgICB2YXIgbWQ1YmxrcyA9IFtdLFxuICAgICAgICAgICAgaTsgLyogQW5keSBLaW5nIHNhaWQgZG8gaXQgdGhpcyB3YXkuICovXG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDY0OyBpICs9IDQpIHtcbiAgICAgICAgICAgIG1kNWJsa3NbaSA+PiAyXSA9IGFbaV0gKyAoYVtpICsgMV0gPDwgOCkgKyAoYVtpICsgMl0gPDwgMTYpICsgKGFbaSArIDNdIDw8IDI0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWQ1YmxrcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtZDUxKHMpIHtcbiAgICAgICAgdmFyIG4gPSBzLmxlbmd0aCxcbiAgICAgICAgICAgIHN0YXRlID0gWzE3MzI1ODQxOTMsIC0yNzE3MzM4NzksIC0xNzMyNTg0MTk0LCAyNzE3MzM4NzhdLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGxlbmd0aCxcbiAgICAgICAgICAgIHRhaWwsXG4gICAgICAgICAgICB0bXAsXG4gICAgICAgICAgICBsbyxcbiAgICAgICAgICAgIGhpO1xuXG4gICAgICAgIGZvciAoaSA9IDY0OyBpIDw9IG47IGkgKz0gNjQpIHtcbiAgICAgICAgICAgIG1kNWN5Y2xlKHN0YXRlLCBtZDVibGsocy5zdWJzdHJpbmcoaSAtIDY0LCBpKSkpO1xuICAgICAgICB9XG4gICAgICAgIHMgPSBzLnN1YnN0cmluZyhpIC0gNjQpO1xuICAgICAgICBsZW5ndGggPSBzLmxlbmd0aDtcbiAgICAgICAgdGFpbCA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB0YWlsW2kgPj4gMl0gfD0gcy5jaGFyQ29kZUF0KGkpIDw8ICgoaSAlIDQpIDw8IDMpO1xuICAgICAgICB9XG4gICAgICAgIHRhaWxbaSA+PiAyXSB8PSAweDgwIDw8ICgoaSAlIDQpIDw8IDMpO1xuICAgICAgICBpZiAoaSA+IDU1KSB7XG4gICAgICAgICAgICBtZDVjeWNsZShzdGF0ZSwgdGFpbCk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIHRhaWxbaV0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmV3YXJlIHRoYXQgdGhlIGZpbmFsIGxlbmd0aCBtaWdodCBub3QgZml0IGluIDMyIGJpdHMgc28gd2UgdGFrZSBjYXJlIG9mIHRoYXRcbiAgICAgICAgdG1wID0gbiAqIDg7XG4gICAgICAgIHRtcCA9IHRtcC50b1N0cmluZygxNikubWF0Y2goLyguKj8pKC57MCw4fSkkLyk7XG4gICAgICAgIGxvID0gcGFyc2VJbnQodG1wWzJdLCAxNik7XG4gICAgICAgIGhpID0gcGFyc2VJbnQodG1wWzFdLCAxNikgfHwgMDtcblxuICAgICAgICB0YWlsWzE0XSA9IGxvO1xuICAgICAgICB0YWlsWzE1XSA9IGhpO1xuXG4gICAgICAgIG1kNWN5Y2xlKHN0YXRlLCB0YWlsKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1kNTFfYXJyYXkoYSkge1xuICAgICAgICB2YXIgbiA9IGEubGVuZ3RoLFxuICAgICAgICAgICAgc3RhdGUgPSBbMTczMjU4NDE5MywgLTI3MTczMzg3OSwgLTE3MzI1ODQxOTQsIDI3MTczMzg3OF0sXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgbGVuZ3RoLFxuICAgICAgICAgICAgdGFpbCxcbiAgICAgICAgICAgIHRtcCxcbiAgICAgICAgICAgIGxvLFxuICAgICAgICAgICAgaGk7XG5cbiAgICAgICAgZm9yIChpID0gNjQ7IGkgPD0gbjsgaSArPSA2NCkge1xuICAgICAgICAgICAgbWQ1Y3ljbGUoc3RhdGUsIG1kNWJsa19hcnJheShhLnN1YmFycmF5KGkgLSA2NCwgaSkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vdCBzdXJlIGlmIGl0IGlzIGEgYnVnLCBob3dldmVyIElFMTAgd2lsbCBhbHdheXMgcHJvZHVjZSBhIHN1YiBhcnJheSBvZiBsZW5ndGggMVxuICAgICAgICAvLyBjb250YWluaW5nIHRoZSBsYXN0IGVsZW1lbnQgb2YgdGhlIHBhcmVudCBhcnJheSBpZiB0aGUgc3ViIGFycmF5IHNwZWNpZmllZCBzdGFydHNcbiAgICAgICAgLy8gYmV5b25kIHRoZSBsZW5ndGggb2YgdGhlIHBhcmVudCBhcnJheSAtIHdlaXJkLlxuICAgICAgICAvLyBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzc3MTQ1Mi90eXBlZC1hcnJheS1zdWJhcnJheS1pc3N1ZVxuICAgICAgICBhID0gKGkgLSA2NCkgPCBuID8gYS5zdWJhcnJheShpIC0gNjQpIDogbmV3IFVpbnQ4QXJyYXkoMCk7XG5cbiAgICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICAgIHRhaWwgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF07XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdGFpbFtpID4+IDJdIHw9IGFbaV0gPDwgKChpICUgNCkgPDwgMyk7XG4gICAgICAgIH1cblxuICAgICAgICB0YWlsW2kgPj4gMl0gfD0gMHg4MCA8PCAoKGkgJSA0KSA8PCAzKTtcbiAgICAgICAgaWYgKGkgPiA1NSkge1xuICAgICAgICAgICAgbWQ1Y3ljbGUoc3RhdGUsIHRhaWwpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDE2OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICB0YWlsW2ldID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJld2FyZSB0aGF0IHRoZSBmaW5hbCBsZW5ndGggbWlnaHQgbm90IGZpdCBpbiAzMiBiaXRzIHNvIHdlIHRha2UgY2FyZSBvZiB0aGF0XG4gICAgICAgIHRtcCA9IG4gKiA4O1xuICAgICAgICB0bXAgPSB0bXAudG9TdHJpbmcoMTYpLm1hdGNoKC8oLio/KSguezAsOH0pJC8pO1xuICAgICAgICBsbyA9IHBhcnNlSW50KHRtcFsyXSwgMTYpO1xuICAgICAgICBoaSA9IHBhcnNlSW50KHRtcFsxXSwgMTYpIHx8IDA7XG5cbiAgICAgICAgdGFpbFsxNF0gPSBsbztcbiAgICAgICAgdGFpbFsxNV0gPSBoaTtcblxuICAgICAgICBtZDVjeWNsZShzdGF0ZSwgdGFpbCk7XG5cbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJoZXgobikge1xuICAgICAgICB2YXIgcyA9ICcnLFxuICAgICAgICAgICAgajtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IDQ7IGogKz0gMSkge1xuICAgICAgICAgICAgcyArPSBoZXhfY2hyWyhuID4+IChqICogOCArIDQpKSAmIDB4MEZdICsgaGV4X2NoclsobiA+PiAoaiAqIDgpKSAmIDB4MEZdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhleCh4KSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgeFtpXSA9IHJoZXgoeFtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHguam9pbignJyk7XG4gICAgfVxuXG4gICAgLy8gSW4gc29tZSBjYXNlcyB0aGUgZmFzdCBhZGQzMiBmdW5jdGlvbiBjYW5ub3QgYmUgdXNlZC4uXG4gICAgaWYgKGhleChtZDUxKCdoZWxsbycpKSAhPT0gJzVkNDE0MDJhYmM0YjJhNzZiOTcxOWQ5MTEwMTdjNTkyJykge1xuICAgICAgICBhZGQzMiA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB2YXIgbHN3ID0gKHggJiAweEZGRkYpICsgKHkgJiAweEZGRkYpLFxuICAgICAgICAgICAgICAgIG1zdyA9ICh4ID4+IDE2KSArICh5ID4+IDE2KSArIChsc3cgPj4gMTYpO1xuICAgICAgICAgICAgcmV0dXJuIChtc3cgPDwgMTYpIHwgKGxzdyAmIDB4RkZGRik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvKipcbiAgICAgKiBBcnJheUJ1ZmZlciBzbGljZSBwb2x5ZmlsbC5cbiAgICAgKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3R0YXViZXJ0L25vZGUtYXJyYXlidWZmZXItc2xpY2VcbiAgICAgKi9cblxuICAgIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmICFBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2UpIHtcbiAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNsYW1wKHZhbCwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gKHZhbCB8IDApIHx8IDA7XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgodmFsICsgbGVuZ3RoLCAwKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5taW4odmFsLCBsZW5ndGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5ieXRlTGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBiZWdpbiA9IGNsYW1wKGZyb20sIGxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IGxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgbnVtLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldEFycmF5LFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VBcnJheTtcblxuICAgICAgICAgICAgICAgIGlmICh0byAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IGNsYW1wKHRvLCBsZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChiZWdpbiA+IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG51bSA9IGVuZCAtIGJlZ2luO1xuICAgICAgICAgICAgICAgIHRhcmdldCA9IG5ldyBBcnJheUJ1ZmZlcihudW0pO1xuICAgICAgICAgICAgICAgIHRhcmdldEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodGFyZ2V0KTtcblxuICAgICAgICAgICAgICAgIHNvdXJjZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodGhpcywgYmVnaW4sIG51bSk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0QXJyYXkuc2V0KHNvdXJjZUFycmF5KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KSgpO1xuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLyoqXG4gICAgICogSGVscGVycy5cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIHRvVXRmOChzdHIpIHtcbiAgICAgICAgaWYgKC9bXFx1MDA4MC1cXHVGRkZGXS8udGVzdChzdHIpKSB7XG4gICAgICAgICAgICBzdHIgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHV0ZjhTdHIyQXJyYXlCdWZmZXIoc3RyLCByZXR1cm5VSW50OEFycmF5KSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBzdHIubGVuZ3RoLFxuICAgICAgICAgICBidWZmID0gbmV3IEFycmF5QnVmZmVyKGxlbmd0aCksXG4gICAgICAgICAgIGFyciA9IG5ldyBVaW50OEFycmF5KGJ1ZmYpLFxuICAgICAgICAgICBpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgYXJyW2ldID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0dXJuVUludDhBcnJheSA/IGFyciA6IGJ1ZmY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXJyYXlCdWZmZXIyVXRmOFN0cihidWZmKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KGJ1ZmYpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25jYXRlbmF0ZUFycmF5QnVmZmVycyhmaXJzdCwgc2Vjb25kLCByZXR1cm5VSW50OEFycmF5KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheShmaXJzdC5ieXRlTGVuZ3RoICsgc2Vjb25kLmJ5dGVMZW5ndGgpO1xuXG4gICAgICAgIHJlc3VsdC5zZXQobmV3IFVpbnQ4QXJyYXkoZmlyc3QpKTtcbiAgICAgICAgcmVzdWx0LnNldChuZXcgVWludDhBcnJheShzZWNvbmQpLCBmaXJzdC5ieXRlTGVuZ3RoKTtcblxuICAgICAgICByZXR1cm4gcmV0dXJuVUludDhBcnJheSA/IHJlc3VsdCA6IHJlc3VsdC5idWZmZXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGV4VG9CaW5hcnlTdHJpbmcoaGV4KSB7XG4gICAgICAgIHZhciBieXRlcyA9IFtdLFxuICAgICAgICAgICAgbGVuZ3RoID0gaGV4Lmxlbmd0aCxcbiAgICAgICAgICAgIHg7XG5cbiAgICAgICAgZm9yICh4ID0gMDsgeCA8IGxlbmd0aCAtIDE7IHggKz0gMikge1xuICAgICAgICAgICAgYnl0ZXMucHVzaChwYXJzZUludChoZXguc3Vic3RyKHgsIDIpLCAxNikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBieXRlcyk7XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvKipcbiAgICAgKiBTcGFya01ENSBPT1AgaW1wbGVtZW50YXRpb24uXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBjbGFzcyB0byBwZXJmb3JtIGFuIGluY3JlbWVudGFsIG1kNSwgb3RoZXJ3aXNlIHVzZSB0aGVcbiAgICAgKiBzdGF0aWMgbWV0aG9kcyBpbnN0ZWFkLlxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gU3BhcmtNRDUoKSB7XG4gICAgICAgIC8vIGNhbGwgcmVzZXQgdG8gaW5pdCB0aGUgaW5zdGFuY2VcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGVuZHMgYSBzdHJpbmcuXG4gICAgICogQSBjb252ZXJzaW9uIHdpbGwgYmUgYXBwbGllZCBpZiBhbiB1dGY4IHN0cmluZyBpcyBkZXRlY3RlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byBiZSBhcHBlbmRlZFxuICAgICAqXG4gICAgICogQHJldHVybiB7U3BhcmtNRDV9IFRoZSBpbnN0YW5jZSBpdHNlbGZcbiAgICAgKi9cbiAgICBTcGFya01ENS5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAvLyBDb252ZXJ0cyB0aGUgc3RyaW5nIHRvIHV0ZjggYnl0ZXMgaWYgbmVjZXNzYXJ5XG4gICAgICAgIC8vIFRoZW4gYXBwZW5kIGFzIGJpbmFyeVxuICAgICAgICB0aGlzLmFwcGVuZEJpbmFyeSh0b1V0Zjgoc3RyKSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFwcGVuZHMgYSBiaW5hcnkgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvbnRlbnRzIFRoZSBiaW5hcnkgc3RyaW5nIHRvIGJlIGFwcGVuZGVkXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTcGFya01ENX0gVGhlIGluc3RhbmNlIGl0c2VsZlxuICAgICAqL1xuICAgIFNwYXJrTUQ1LnByb3RvdHlwZS5hcHBlbmRCaW5hcnkgPSBmdW5jdGlvbiAoY29udGVudHMpIHtcbiAgICAgICAgdGhpcy5fYnVmZiArPSBjb250ZW50cztcbiAgICAgICAgdGhpcy5fbGVuZ3RoICs9IGNvbnRlbnRzLmxlbmd0aDtcblxuICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5fYnVmZi5sZW5ndGgsXG4gICAgICAgICAgICBpO1xuXG4gICAgICAgIGZvciAoaSA9IDY0OyBpIDw9IGxlbmd0aDsgaSArPSA2NCkge1xuICAgICAgICAgICAgbWQ1Y3ljbGUodGhpcy5faGFzaCwgbWQ1YmxrKHRoaXMuX2J1ZmYuc3Vic3RyaW5nKGkgLSA2NCwgaSkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2J1ZmYgPSB0aGlzLl9idWZmLnN1YnN0cmluZyhpIC0gNjQpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaW5pc2hlcyB0aGUgaW5jcmVtZW50YWwgY29tcHV0YXRpb24sIHJlc2V0aW5nIHRoZSBpbnRlcm5hbCBzdGF0ZSBhbmRcbiAgICAgKiByZXR1cm5pbmcgdGhlIHJlc3VsdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmF3IFRydWUgdG8gZ2V0IHRoZSByYXcgc3RyaW5nLCBmYWxzZSB0byBnZXQgdGhlIGhleCBzdHJpbmdcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHJlc3VsdFxuICAgICAqL1xuICAgIFNwYXJrTUQ1LnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAocmF3KSB7XG4gICAgICAgIHZhciBidWZmID0gdGhpcy5fYnVmZixcbiAgICAgICAgICAgIGxlbmd0aCA9IGJ1ZmYubGVuZ3RoLFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIHRhaWwgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF0sXG4gICAgICAgICAgICByZXQ7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB0YWlsW2kgPj4gMl0gfD0gYnVmZi5jaGFyQ29kZUF0KGkpIDw8ICgoaSAlIDQpIDw8IDMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZmluaXNoKHRhaWwsIGxlbmd0aCk7XG4gICAgICAgIHJldCA9IGhleCh0aGlzLl9oYXNoKTtcblxuICAgICAgICBpZiAocmF3KSB7XG4gICAgICAgICAgICByZXQgPSBoZXhUb0JpbmFyeVN0cmluZyhyZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZXNldCgpO1xuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgaW50ZXJuYWwgc3RhdGUgb2YgdGhlIGNvbXB1dGF0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U3BhcmtNRDV9IFRoZSBpbnN0YW5jZSBpdHNlbGZcbiAgICAgKi9cbiAgICBTcGFya01ENS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2J1ZmYgPSAnJztcbiAgICAgICAgdGhpcy5fbGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5faGFzaCA9IFsxNzMyNTg0MTkzLCAtMjcxNzMzODc5LCAtMTczMjU4NDE5NCwgMjcxNzMzODc4XTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW50ZXJuYWwgc3RhdGUgb2YgdGhlIGNvbXB1dGF0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgc3RhdGVcbiAgICAgKi9cbiAgICBTcGFya01ENS5wcm90b3R5cGUuZ2V0U3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBidWZmOiB0aGlzLl9idWZmLFxuICAgICAgICAgICAgbGVuZ3RoOiB0aGlzLl9sZW5ndGgsXG4gICAgICAgICAgICBoYXNoOiB0aGlzLl9oYXNoLnNsaWNlKClcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW50ZXJuYWwgc3RhdGUgb2YgdGhlIGNvbXB1dGF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIFRoZSBzdGF0ZVxuICAgICAqXG4gICAgICogQHJldHVybiB7U3BhcmtNRDV9IFRoZSBpbnN0YW5jZSBpdHNlbGZcbiAgICAgKi9cbiAgICBTcGFya01ENS5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdGhpcy5fYnVmZiA9IHN0YXRlLmJ1ZmY7XG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgdGhpcy5faGFzaCA9IHN0YXRlLmhhc2g7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbGVhc2VzIG1lbW9yeSB1c2VkIGJ5IHRoZSBpbmNyZW1lbnRhbCBidWZmZXIgYW5kIG90aGVyIGFkZGl0aW9uYWxcbiAgICAgKiByZXNvdXJjZXMuIElmIHlvdSBwbGFuIHRvIHVzZSB0aGUgaW5zdGFuY2UgYWdhaW4sIHVzZSByZXNldCBpbnN0ZWFkLlxuICAgICAqL1xuICAgIFNwYXJrTUQ1LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBkZWxldGUgdGhpcy5faGFzaDtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2J1ZmY7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9sZW5ndGg7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEZpbmlzaCB0aGUgZmluYWwgY2FsY3VsYXRpb24gYmFzZWQgb24gdGhlIHRhaWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSAgdGFpbCAgIFRoZSB0YWlsICh3aWxsIGJlIG1vZGlmaWVkKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggVGhlIGxlbmd0aCBvZiB0aGUgcmVtYWluaW5nIGJ1ZmZlclxuICAgICAqL1xuICAgIFNwYXJrTUQ1LnByb3RvdHlwZS5fZmluaXNoID0gZnVuY3Rpb24gKHRhaWwsIGxlbmd0aCkge1xuICAgICAgICB2YXIgaSA9IGxlbmd0aCxcbiAgICAgICAgICAgIHRtcCxcbiAgICAgICAgICAgIGxvLFxuICAgICAgICAgICAgaGk7XG5cbiAgICAgICAgdGFpbFtpID4+IDJdIHw9IDB4ODAgPDwgKChpICUgNCkgPDwgMyk7XG4gICAgICAgIGlmIChpID4gNTUpIHtcbiAgICAgICAgICAgIG1kNWN5Y2xlKHRoaXMuX2hhc2gsIHRhaWwpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDE2OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICB0YWlsW2ldID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERvIHRoZSBmaW5hbCBjb21wdXRhdGlvbiBiYXNlZCBvbiB0aGUgdGFpbCBhbmQgbGVuZ3RoXG4gICAgICAgIC8vIEJld2FyZSB0aGF0IHRoZSBmaW5hbCBsZW5ndGggbWF5IG5vdCBmaXQgaW4gMzIgYml0cyBzbyB3ZSB0YWtlIGNhcmUgb2YgdGhhdFxuICAgICAgICB0bXAgPSB0aGlzLl9sZW5ndGggKiA4O1xuICAgICAgICB0bXAgPSB0bXAudG9TdHJpbmcoMTYpLm1hdGNoKC8oLio/KSguezAsOH0pJC8pO1xuICAgICAgICBsbyA9IHBhcnNlSW50KHRtcFsyXSwgMTYpO1xuICAgICAgICBoaSA9IHBhcnNlSW50KHRtcFsxXSwgMTYpIHx8IDA7XG5cbiAgICAgICAgdGFpbFsxNF0gPSBsbztcbiAgICAgICAgdGFpbFsxNV0gPSBoaTtcbiAgICAgICAgbWQ1Y3ljbGUodGhpcy5faGFzaCwgdGFpbCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIHRoZSBtZDUgaGFzaCBvbiBhIHN0cmluZy5cbiAgICAgKiBBIGNvbnZlcnNpb24gd2lsbCBiZSBhcHBsaWVkIGlmIHV0Zjggc3RyaW5nIGlzIGRldGVjdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICBzdHIgVGhlIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3Jhd10gVHJ1ZSB0byBnZXQgdGhlIHJhdyBzdHJpbmcsIGZhbHNlIHRvIGdldCB0aGUgaGV4IHN0cmluZ1xuICAgICAqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgcmVzdWx0XG4gICAgICovXG4gICAgU3BhcmtNRDUuaGFzaCA9IGZ1bmN0aW9uIChzdHIsIHJhdykge1xuICAgICAgICAvLyBDb252ZXJ0cyB0aGUgc3RyaW5nIHRvIHV0ZjggYnl0ZXMgaWYgbmVjZXNzYXJ5XG4gICAgICAgIC8vIFRoZW4gY29tcHV0ZSBpdCB1c2luZyB0aGUgYmluYXJ5IGZ1bmN0aW9uXG4gICAgICAgIHJldHVybiBTcGFya01ENS5oYXNoQmluYXJ5KHRvVXRmOChzdHIpLCByYXcpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyB0aGUgbWQ1IGhhc2ggb24gYSBiaW5hcnkgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9ICBjb250ZW50IFRoZSBiaW5hcnkgc3RyaW5nXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbcmF3XSAgICAgVHJ1ZSB0byBnZXQgdGhlIHJhdyBzdHJpbmcsIGZhbHNlIHRvIGdldCB0aGUgaGV4IHN0cmluZ1xuICAgICAqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgcmVzdWx0XG4gICAgICovXG4gICAgU3BhcmtNRDUuaGFzaEJpbmFyeSA9IGZ1bmN0aW9uIChjb250ZW50LCByYXcpIHtcbiAgICAgICAgdmFyIGhhc2ggPSBtZDUxKGNvbnRlbnQpLFxuICAgICAgICAgICAgcmV0ID0gaGV4KGhhc2gpO1xuXG4gICAgICAgIHJldHVybiByYXcgPyBoZXhUb0JpbmFyeVN0cmluZyhyZXQpIDogcmV0O1xuICAgIH07XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8qKlxuICAgICAqIFNwYXJrTUQ1IE9PUCBpbXBsZW1lbnRhdGlvbiBmb3IgYXJyYXkgYnVmZmVycy5cbiAgICAgKlxuICAgICAqIFVzZSB0aGlzIGNsYXNzIHRvIHBlcmZvcm0gYW4gaW5jcmVtZW50YWwgbWQ1IE9OTFkgZm9yIGFycmF5IGJ1ZmZlcnMuXG4gICAgICovXG4gICAgU3BhcmtNRDUuQXJyYXlCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGNhbGwgcmVzZXQgdG8gaW5pdCB0aGUgaW5zdGFuY2VcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIGFuIGFycmF5IGJ1ZmZlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFyciBUaGUgYXJyYXkgdG8gYmUgYXBwZW5kZWRcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NwYXJrTUQ1LkFycmF5QnVmZmVyfSBUaGUgaW5zdGFuY2UgaXRzZWxmXG4gICAgICovXG4gICAgU3BhcmtNRDUuQXJyYXlCdWZmZXIucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgICAgICAgdmFyIGJ1ZmYgPSBjb25jYXRlbmF0ZUFycmF5QnVmZmVycyh0aGlzLl9idWZmLmJ1ZmZlciwgYXJyLCB0cnVlKSxcbiAgICAgICAgICAgIGxlbmd0aCA9IGJ1ZmYubGVuZ3RoLFxuICAgICAgICAgICAgaTtcblxuICAgICAgICB0aGlzLl9sZW5ndGggKz0gYXJyLmJ5dGVMZW5ndGg7XG5cbiAgICAgICAgZm9yIChpID0gNjQ7IGkgPD0gbGVuZ3RoOyBpICs9IDY0KSB7XG4gICAgICAgICAgICBtZDVjeWNsZSh0aGlzLl9oYXNoLCBtZDVibGtfYXJyYXkoYnVmZi5zdWJhcnJheShpIC0gNjQsIGkpKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9idWZmID0gKGkgLSA2NCkgPCBsZW5ndGggPyBuZXcgVWludDhBcnJheShidWZmLmJ1ZmZlci5zbGljZShpIC0gNjQpKSA6IG5ldyBVaW50OEFycmF5KDApO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGaW5pc2hlcyB0aGUgaW5jcmVtZW50YWwgY29tcHV0YXRpb24sIHJlc2V0aW5nIHRoZSBpbnRlcm5hbCBzdGF0ZSBhbmRcbiAgICAgKiByZXR1cm5pbmcgdGhlIHJlc3VsdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmF3IFRydWUgdG8gZ2V0IHRoZSByYXcgc3RyaW5nLCBmYWxzZSB0byBnZXQgdGhlIGhleCBzdHJpbmdcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHJlc3VsdFxuICAgICAqL1xuICAgIFNwYXJrTUQ1LkFycmF5QnVmZmVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAocmF3KSB7XG4gICAgICAgIHZhciBidWZmID0gdGhpcy5fYnVmZixcbiAgICAgICAgICAgIGxlbmd0aCA9IGJ1ZmYubGVuZ3RoLFxuICAgICAgICAgICAgdGFpbCA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwXSxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICByZXQ7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB0YWlsW2kgPj4gMl0gfD0gYnVmZltpXSA8PCAoKGkgJSA0KSA8PCAzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2ZpbmlzaCh0YWlsLCBsZW5ndGgpO1xuICAgICAgICByZXQgPSBoZXgodGhpcy5faGFzaCk7XG5cbiAgICAgICAgaWYgKHJhdykge1xuICAgICAgICAgICAgcmV0ID0gaGV4VG9CaW5hcnlTdHJpbmcocmV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucmVzZXQoKTtcblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIGludGVybmFsIHN0YXRlIG9mIHRoZSBjb21wdXRhdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NwYXJrTUQ1LkFycmF5QnVmZmVyfSBUaGUgaW5zdGFuY2UgaXRzZWxmXG4gICAgICovXG4gICAgU3BhcmtNRDUuQXJyYXlCdWZmZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9idWZmID0gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuX2hhc2ggPSBbMTczMjU4NDE5MywgLTI3MTczMzg3OSwgLTE3MzI1ODQxOTQsIDI3MTczMzg3OF07XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGludGVybmFsIHN0YXRlIG9mIHRoZSBjb21wdXRhdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIHN0YXRlXG4gICAgICovXG4gICAgU3BhcmtNRDUuQXJyYXlCdWZmZXIucHJvdG90eXBlLmdldFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RhdGUgPSBTcGFya01ENS5wcm90b3R5cGUuZ2V0U3RhdGUuY2FsbCh0aGlzKTtcblxuICAgICAgICAvLyBDb252ZXJ0IGJ1ZmZlciB0byBhIHN0cmluZ1xuICAgICAgICBzdGF0ZS5idWZmID0gYXJyYXlCdWZmZXIyVXRmOFN0cihzdGF0ZS5idWZmKTtcblxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGludGVybmFsIHN0YXRlIG9mIHRoZSBjb21wdXRhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSBUaGUgc3RhdGVcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NwYXJrTUQ1LkFycmF5QnVmZmVyfSBUaGUgaW5zdGFuY2UgaXRzZWxmXG4gICAgICovXG4gICAgU3BhcmtNRDUuQXJyYXlCdWZmZXIucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIGJ1ZmZlclxuICAgICAgICBzdGF0ZS5idWZmID0gdXRmOFN0cjJBcnJheUJ1ZmZlcihzdGF0ZS5idWZmLCB0cnVlKTtcblxuICAgICAgICByZXR1cm4gU3BhcmtNRDUucHJvdG90eXBlLnNldFN0YXRlLmNhbGwodGhpcywgc3RhdGUpO1xuICAgIH07XG5cbiAgICBTcGFya01ENS5BcnJheUJ1ZmZlci5wcm90b3R5cGUuZGVzdHJveSA9IFNwYXJrTUQ1LnByb3RvdHlwZS5kZXN0cm95O1xuXG4gICAgU3BhcmtNRDUuQXJyYXlCdWZmZXIucHJvdG90eXBlLl9maW5pc2ggPSBTcGFya01ENS5wcm90b3R5cGUuX2ZpbmlzaDtcblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIHRoZSBtZDUgaGFzaCBvbiBhbiBhcnJheSBidWZmZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBhcnIgVGhlIGFycmF5IGJ1ZmZlclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gICAgIFtyYXddIFRydWUgdG8gZ2V0IHRoZSByYXcgc3RyaW5nLCBmYWxzZSB0byBnZXQgdGhlIGhleCBvbmVcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHJlc3VsdFxuICAgICAqL1xuICAgIFNwYXJrTUQ1LkFycmF5QnVmZmVyLmhhc2ggPSBmdW5jdGlvbiAoYXJyLCByYXcpIHtcbiAgICAgICAgdmFyIGhhc2ggPSBtZDUxX2FycmF5KG5ldyBVaW50OEFycmF5KGFycikpLFxuICAgICAgICAgICAgcmV0ID0gaGV4KGhhc2gpO1xuXG4gICAgICAgIHJldHVybiByYXcgPyBoZXhUb0JpbmFyeVN0cmluZyhyZXQpIDogcmV0O1xuICAgIH07XG5cbiAgICByZXR1cm4gU3BhcmtNRDU7XG59KSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2hhbm5lbCA9IHZvaWQgMDtcbmNvbnN0IGludGVyZmFjZXNfMSA9IHJlcXVpcmUoXCIuL2ludGVyZmFjZXNcIik7XG5jb25zdCB2ZWxveF8xID0gcmVxdWlyZShcIi4vdmVsb3hcIik7XG5jbGFzcyBDaGFubmVsIHtcbiAgICBjb25zdHJ1Y3RvcihTTk1IYW5kbGVyLCBSQ01IYW5kbGVyLCBDTVVIYW5kbGVyLCBNQkhhbmRsZXIsIEJsb2JNb3VudCwgUlRDQ29uZmlnKSB7XG4gICAgICAgIHRoaXMuX1NDTVF1ZXVlID0gW107XG4gICAgICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9TTk1IYW5kbGVyID0gU05NSGFuZGxlcjtcbiAgICAgICAgdGhpcy5fUkNNSGFuZGxlciA9IFJDTUhhbmRsZXI7XG4gICAgICAgIHRoaXMuX0NNVUhhbmRsZXIgPSBDTVVIYW5kbGVyO1xuICAgICAgICB0aGlzLl9NQkhhbmRsZXIgPSBNQkhhbmRsZXI7XG4gICAgICAgIHRoaXMuX0JNQWNjZXNzID0gQmxvYk1vdW50O1xuICAgICAgICBpZiAoUlRDQ29uZmlnKSB7XG4gICAgICAgICAgICB0aGlzLl9wZWVyQ29ubmVjdGlvbiA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbihSVENDb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcGVlckNvbm5lY3Rpb24gPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oe1xuICAgICAgICAgICAgICAgIGljZVNlcnZlcnM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsczogXCJzdHVuOnN0dW4uMS5nb29nbGUuY29tOjE5MzAyXCJcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIFNDTVByb2Nlc3Nvcihtc2cpIHtcbiAgICAgICAgY29uc3QgbXNnU3RyID0gSlNPTi5zdHJpbmdpZnkobXNnKTtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUobXNnU3RyKTtcbiAgICAgICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtieXRlc10sIHtcbiAgICAgICAgICAgIHR5cGU6IFwiYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04XCJcbiAgICAgICAgfSk7XG4gICAgICAgIGJsb2IuYXJyYXlCdWZmZXIoKS50aGVuKChibG9iRGF0YSkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RhdGFDaGFubmVsLnNlbmQoYmxvYkRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fU0NNUXVldWUucHVzaChtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgUmF3TWVzc2FnZShhYikge1xuICAgICAgICB0aGlzLl9kYXRhQ2hhbm5lbC5zZW5kKGFiKTtcbiAgICB9XG4gICAgZXhlY3V0ZVNDTVF1ZXVlKCkge1xuICAgICAgICB3aGlsZSAodGhpcy5fU0NNUXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5TQ01Qcm9jZXNzb3IodGhpcy5fU0NNUXVldWUucG9wKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFJOTVByb2Nlc3NvcihtZXNzYWdlKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLlR5cGUgPT0gaW50ZXJmYWNlc18xLlJlY2lldmFibGVOZXN0TWVzc2FnZVR5cGUuU3RhcnRIYW5kc2hha2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3BlZXJVVUlEID0gbWVzc2FnZS5VVUlEO1xuICAgICAgICAgICAgdGhpcy5fZGF0YUNoYW5uZWwgPSB0aGlzLl9wZWVyQ29ubmVjdGlvbi5jcmVhdGVEYXRhQ2hhbm5lbChcIm1cIik7XG4gICAgICAgICAgICB0aGlzLl9kYXRhQ2hhbm5lbC5iaW5hcnlUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xuICAgICAgICAgICAgdGhpcy5fZGF0YUNoYW5uZWwub25tZXNzYWdlID0gKGV2KSA9PiB0aGlzLl9vbm1lc3NhZ2VIYW5kbGVyKGV2KTtcbiAgICAgICAgICAgIHRoaXMuX2RhdGFDaGFubmVsLm9ub3BlbiA9IChldikgPT4gdGhpcy5fb25PcGVuSGFuZGxlcihldik7XG4gICAgICAgICAgICB0aGlzLl9kYXRhQ2hhbm5lbC5vbmNsb3NlID0gKGV2KSA9PiB0aGlzLl9vbkNsb3NlSGFuZGxlcihldik7XG4gICAgICAgICAgICB0aGlzLl9wZWVyQ29ubmVjdGlvbi5jcmVhdGVPZmZlcigpLnRoZW4oKG9mZmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGVlckNvbm5lY3Rpb24uc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICAgICAgY29uc3QgbXNnID0ge1xuICAgICAgICAgICAgICAgICAgICBVVUlEOiB0aGlzLl9wZWVyVVVJRCxcbiAgICAgICAgICAgICAgICAgICAgU0RQT2ZmZXI6IG9mZmVyLFxuICAgICAgICAgICAgICAgICAgICBUeXBlOiBpbnRlcmZhY2VzXzEuU2VuZGFibGVOZXN0TWVzc2FnZVR5cGUuT2ZmZXJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMuX1NOTUhhbmRsZXIobXNnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1lc3NhZ2UuVHlwZSA9PSBpbnRlcmZhY2VzXzEuUmVjaWV2YWJsZU5lc3RNZXNzYWdlVHlwZS5PZmZlcikge1xuICAgICAgICAgICAgdGhpcy5fcGVlclVVSUQgPSBtZXNzYWdlLlVVSUQ7XG4gICAgICAgICAgICB0aGlzLl9wZWVyQ29ubmVjdGlvbi5vbmRhdGFjaGFubmVsID0gKGV2KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGF0YUNoYW5uZWwgPSBldi5jaGFubmVsO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RhdGFDaGFubmVsLmJpbmFyeVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGF0YUNoYW5uZWwub25tZXNzYWdlID0gKGV2KSA9PiB0aGlzLl9vbm1lc3NhZ2VIYW5kbGVyKGV2KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kYXRhQ2hhbm5lbC5vbm9wZW4gPSAoZXYpID0+IHRoaXMuX29uT3BlbkhhbmRsZXIoZXYpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RhdGFDaGFubmVsLm9uY2xvc2UgPSAoZXYpID0+IHRoaXMuX29uQ2xvc2VIYW5kbGVyKGV2KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl9wZWVyQ29ubmVjdGlvbi5zZXRSZW1vdGVEZXNjcmlwdGlvbihuZXcgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKG1lc3NhZ2UuU0RQT2ZmZXIpKTtcbiAgICAgICAgICAgIHRoaXMuX3BlZXJDb25uZWN0aW9uLmNyZWF0ZUFuc3dlcigpLnRoZW4oKGFuc3dlcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BlZXJDb25uZWN0aW9uLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSB7XG4gICAgICAgICAgICAgICAgICAgIFVVSUQ6IHRoaXMuX3BlZXJVVUlELFxuICAgICAgICAgICAgICAgICAgICBTRFBPZmZlcjogYW5zd2VyLFxuICAgICAgICAgICAgICAgICAgICBUeXBlOiBpbnRlcmZhY2VzXzEuU2VuZGFibGVOZXN0TWVzc2FnZVR5cGUuQW5zd2VyXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLl9TTk1IYW5kbGVyKG1zZyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGVlckNvbm5lY3Rpb24ub25pY2VjYW5kaWRhdGUgPSAoeyBjYW5kaWRhdGUgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBVVUlEOiB0aGlzLl9wZWVyVVVJRCxcbiAgICAgICAgICAgICAgICAgICAgICAgIENhbmRpZGF0ZTogY2FuZGlkYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgVHlwZTogaW50ZXJmYWNlc18xLlNlbmRhYmxlTmVzdE1lc3NhZ2VUeXBlLklDRVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9TTk1IYW5kbGVyKG1zZyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1lc3NhZ2UuVHlwZSA9PSBpbnRlcmZhY2VzXzEuUmVjaWV2YWJsZU5lc3RNZXNzYWdlVHlwZS5BbnN3ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3BlZXJDb25uZWN0aW9uLnNldFJlbW90ZURlc2NyaXB0aW9uKG5ldyBSVENTZXNzaW9uRGVzY3JpcHRpb24obWVzc2FnZS5TRFBPZmZlcikpO1xuICAgICAgICAgICAgdGhpcy5fcGVlckNvbm5lY3Rpb24ub25pY2VjYW5kaWRhdGUgPSAoeyBjYW5kaWRhdGUgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1zZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgVVVJRDogdGhpcy5fcGVlclVVSUQsXG4gICAgICAgICAgICAgICAgICAgIENhbmRpZGF0ZTogY2FuZGlkYXRlLFxuICAgICAgICAgICAgICAgICAgICBUeXBlOiBpbnRlcmZhY2VzXzEuU2VuZGFibGVOZXN0TWVzc2FnZVR5cGUuSUNFXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLl9TTk1IYW5kbGVyKG1zZyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1lc3NhZ2UuVHlwZSA9PSBpbnRlcmZhY2VzXzEuUmVjaWV2YWJsZU5lc3RNZXNzYWdlVHlwZS5JQ0UpIHtcbiAgICAgICAgICAgIHRoaXMuX3BlZXJDb25uZWN0aW9uLmFkZEljZUNhbmRpZGF0ZShtZXNzYWdlLkNhbmRpZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImRlZmF1bHRcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX29uT3BlbkhhbmRsZXIoZXYpIHtcbiAgICAgICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgbWV0YV91cGRhdGUgPSB7IFBlZXI6IHRoaXMuX3BlZXJVVUlELCBVcGRhdGU6IFwiT3BlbmVkXCIgfTtcbiAgICAgICAgdGhpcy5fQ01VSGFuZGxlcihtZXRhX3VwZGF0ZSk7XG4gICAgICAgIHRoaXMuZXhlY3V0ZVNDTVF1ZXVlKCk7XG4gICAgfVxuICAgIF9vbm1lc3NhZ2VIYW5kbGVyKGV2KSB7XG4gICAgICAgIGNvbnN0IGggPSAoMCwgdmVsb3hfMS5oYXNoQUIpKGV2LmRhdGEpO1xuICAgICAgICBpZiAoIXRoaXMuX0JNQWNjZXNzLmhhcyhoKSkge1xuICAgICAgICAgICAgdGhpcy5fQk1BY2Nlc3Muc2V0KGgsIGV2LmRhdGEpO1xuICAgICAgICAgICAgdGhpcy5fTUJIYW5kbGVyKHsgSGFzaDogaCB9KTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QganNvblN0cmluZyA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShldi5kYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IEpTT04ucGFyc2UoanNvblN0cmluZyk7XG4gICAgICAgICAgICB0aGlzLl9SQ01IYW5kbGVyKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbXNnKSwgeyBVVUlEOiB0aGlzLl9wZWVyVVVJRCB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfb25DbG9zZUhhbmRsZXIoZXYpIHtcbiAgICAgICAgY29uc3QgbWV0YV91cGRhdGUgPSB7IFBlZXI6IHRoaXMuX3BlZXJVVUlELCBVcGRhdGU6IFwiQ2xvc2VkXCIgfTtcbiAgICAgICAgdGhpcy5fQ01VSGFuZGxlcihtZXRhX3VwZGF0ZSk7XG4gICAgfVxufVxuZXhwb3J0cy5DaGFubmVsID0gQ2hhbm5lbDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TZW5kYWJsZU5lc3RNZXNzYWdlVHlwZSA9IGV4cG9ydHMuUmVjaWV2YWJsZU5lc3RNZXNzYWdlVHlwZSA9IHZvaWQgMDtcbnZhciBSZWNpZXZhYmxlTmVzdE1lc3NhZ2VUeXBlO1xuKGZ1bmN0aW9uIChSZWNpZXZhYmxlTmVzdE1lc3NhZ2VUeXBlKSB7XG4gICAgUmVjaWV2YWJsZU5lc3RNZXNzYWdlVHlwZVtcIkluaXRpYWxcIl0gPSBcIklOXCI7XG4gICAgUmVjaWV2YWJsZU5lc3RNZXNzYWdlVHlwZVtcIlN0YXJ0SGFuZHNoYWtlXCJdID0gXCJTSFwiO1xuICAgIFJlY2lldmFibGVOZXN0TWVzc2FnZVR5cGVbXCJPZmZlclwiXSA9IFwiT0ZcIjtcbiAgICBSZWNpZXZhYmxlTmVzdE1lc3NhZ2VUeXBlW1wiQW5zd2VyXCJdID0gXCJBTlwiO1xuICAgIFJlY2lldmFibGVOZXN0TWVzc2FnZVR5cGVbXCJJQ0VcIl0gPSBcIkNcIjtcbn0pKFJlY2lldmFibGVOZXN0TWVzc2FnZVR5cGUgPSBleHBvcnRzLlJlY2lldmFibGVOZXN0TWVzc2FnZVR5cGUgfHwgKGV4cG9ydHMuUmVjaWV2YWJsZU5lc3RNZXNzYWdlVHlwZSA9IHt9KSk7XG52YXIgU2VuZGFibGVOZXN0TWVzc2FnZVR5cGU7XG4oZnVuY3Rpb24gKFNlbmRhYmxlTmVzdE1lc3NhZ2VUeXBlKSB7XG4gICAgU2VuZGFibGVOZXN0TWVzc2FnZVR5cGVbXCJJbml0aWFsXCJdID0gXCJJTlwiO1xuICAgIFNlbmRhYmxlTmVzdE1lc3NhZ2VUeXBlW1wiT2ZmZXJcIl0gPSBcIk9GXCI7XG4gICAgU2VuZGFibGVOZXN0TWVzc2FnZVR5cGVbXCJBbnN3ZXJcIl0gPSBcIkFOXCI7XG4gICAgU2VuZGFibGVOZXN0TWVzc2FnZVR5cGVbXCJJQ0VcIl0gPSBcIkNcIjtcbn0pKFNlbmRhYmxlTmVzdE1lc3NhZ2VUeXBlID0gZXhwb3J0cy5TZW5kYWJsZU5lc3RNZXNzYWdlVHlwZSB8fCAoZXhwb3J0cy5TZW5kYWJsZU5lc3RNZXNzYWdlVHlwZSA9IHt9KSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTmVzdCA9IHZvaWQgMDtcbmNsYXNzIE5lc3Qge1xuICAgIGNvbnN0cnVjdG9yKHNvY2tBZGRyLCBSTk1IYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zb2NrQWRkciA9IFwid3M6MTM5LjE0NC4zMC43NDo4MC9uZXN0XCI7XG4gICAgICAgIGlmIChzb2NrQWRkciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9zb2NrQWRkciA9IHNvY2tBZGRyO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dzID0gbmV3IFdlYlNvY2tldCh0aGlzLl9zb2NrQWRkcik7XG4gICAgICAgIHRoaXMuX3dzLm9ub3BlbiA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIm9wZW5lZCBjb25uZWN0aW9uIHRvIG5lc3RcIik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3dzLm9ubWVzc2FnZSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICBSTk1IYW5kbGVyKG1lc3NhZ2UpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl93cy5vbmNsb3NlID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJjb25uZWN0aW9uIHdpdGggdGhlIG5lc3QgaGFzIGJlZW4gY2xvc2VkXCIpO1xuICAgICAgICAgICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3dzLm9uZXJyb3IgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuX3dzLmNsb3NlO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpc0FjdGl2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZTtcbiAgICB9XG4gICAgU05NUHJvY2Vzc29yKFNOTSkge1xuICAgICAgICBjb25zdCBkdGEgPSBKU09OLnN0cmluZ2lmeShTTk0pO1xuICAgICAgICB0aGlzLl93cy5zZW5kKGR0YSk7XG4gICAgfVxufVxuZXhwb3J0cy5OZXN0ID0gTmVzdDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5oYXNoQUIgPSBleHBvcnRzLlZlbG94ID0gdm9pZCAwO1xuY29uc3QgY2hhbm5lbF8xID0gcmVxdWlyZShcIi4vY2hhbm5lbFwiKTtcbmNvbnN0IG5lc3RfMSA9IHJlcXVpcmUoXCIuL25lc3RcIik7XG5jb25zdCBpbnRlcmZhY2VzXzEgPSByZXF1aXJlKFwiLi9pbnRlcmZhY2VzXCIpO1xuY29uc3QgU3BhcmtNRDUgPSByZXF1aXJlKFwic3BhcmstbWQ1XCIpO1xuY2xhc3MgVmVsb3gge1xuICAgIGNvbnN0cnVjdG9yKHNvY2tldEFkZHIsIFJUQ0NvbmZpZykge1xuICAgICAgICB0aGlzLl9iZWFjb24gPSBuZXcgRXZlbnRUYXJnZXQoKTtcbiAgICAgICAgdGhpcy5fbW91bnRlZEJsb2JzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9ibG9iSW5mbyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fYmxvYlJMb29rdXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX29uQ2hhbm5lbE9wZW5lZCA9IChVVUlEKSA9PiBjb25zb2xlLmxvZyhVVUlEICsgXCIgT3BlbmVkXCIpO1xuICAgICAgICB0aGlzLl9vbkNoYW5uZWxDbG9zZWQgPSAoVVVJRCkgPT4gY29uc29sZS5sb2coVVVJRCArIFwiIENsb3NlZFwiKTtcbiAgICAgICAgdGhpcy5fYWN0aXZlQ2hhbm5lbHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VDYWxsYmFja01hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fZGVmYXVsdE1lc3NhZ2VDYWxsYmFjayA9IChjbSkgPT4geyBjb25zb2xlLmxvZyhjbSk7IH07XG4gICAgICAgIGNvbnN0IFJDTUhhbmRsZXIgPSAobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fYmVhY29uLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwiUkNNXCIsIHsgZGV0YWlsOiB7IENNOiBtZXNzYWdlIH0gfSkpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBTTk1IYW5kbGVyID0gKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2JlYWNvbi5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChcIlNOTVwiLCB7IGRldGFpbDogeyBTTk06IG1lc3NhZ2UgfSB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IFJOTUhhbmRsZXIgPSAobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fYmVhY29uLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwiUk5NXCIsIHsgZGV0YWlsOiB7IFJOTTogbWVzc2FnZSB9IH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgQ01VSGFuZGxlciA9IChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9iZWFjb24uZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXCJDTVVcIiwgeyBkZXRhaWw6IHsgQ01VOiBtZXNzYWdlIH0gfSkpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBNQkhhbmRsZXIgPSAobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fYmVhY29uLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwiTUJcIiwgeyBkZXRhaWw6IHsgSGFzaDogbWVzc2FnZS5IYXNoIH0gfSkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9iZWFjb24uYWRkRXZlbnRMaXN0ZW5lcihcIk1CXCIsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaCA9IGV2ZW50LmRldGFpbC5IYXNoO1xuICAgICAgICAgICAgaWYgKHRoaXMuX21vdW50ZWRCbG9icy5oYXMoaCkgJiYgdGhpcy5fYmxvYkluZm8uaGFzKGgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmVhY29uLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwiQk1DXCIsIHsgZGV0YWlsOiB7IElkOiB0aGlzLl9ibG9iSW5mby5nZXQoaCkuSWQsIFR5cGU6IHRoaXMuX2Jsb2JJbmZvLmdldChoKS5UeXBlLCBBQjogdGhpcy5fbW91bnRlZEJsb2JzLmdldChoKSB9IH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2JlYWNvbi5hZGRFdmVudExpc3RlbmVyKFwiUk5NXCIsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGV2ZW50LmRldGFpbC5STk07XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5UeXBlID09IGludGVyZmFjZXNfMS5SZWNpZXZhYmxlTmVzdE1lc3NhZ2VUeXBlLkluaXRpYWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9VVUlEID0gbWVzc2FnZS5VVUlEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobWVzc2FnZS5UeXBlID09IGludGVyZmFjZXNfMS5SZWNpZXZhYmxlTmVzdE1lc3NhZ2VUeXBlLlN0YXJ0SGFuZHNoYWtlIHx8IG1lc3NhZ2UuVHlwZSA9PSBpbnRlcmZhY2VzXzEuUmVjaWV2YWJsZU5lc3RNZXNzYWdlVHlwZS5PZmZlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZUNoYW5uZWxzLnNldChtZXNzYWdlLlVVSUQsIG5ldyBjaGFubmVsXzEuQ2hhbm5lbChTTk1IYW5kbGVyLCBSQ01IYW5kbGVyLCBDTVVIYW5kbGVyLCBNQkhhbmRsZXIsIHRoaXMuX21vdW50ZWRCbG9icywgUlRDQ29uZmlnKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmVhY29uLmFkZEV2ZW50TGlzdGVuZXIobWVzc2FnZS5VVUlELCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlQ2hhbm5lbHMuZ2V0KG1lc3NhZ2UuVVVJRCkuUk5NUHJvY2Vzc29yKGV2ZW50LmRldGFpbC5STk0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2JlYWNvbi5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChtZXNzYWdlLlVVSUQsIHsgZGV0YWlsOiB7IFJOTTogbWVzc2FnZSB9IH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1lc3NhZ2UuVVVJRCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmVhY29uLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KG1lc3NhZ2UuVVVJRCwgeyBkZXRhaWw6IHsgUk5NOiBtZXNzYWdlIH0gfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fYmVhY29uLmFkZEV2ZW50TGlzdGVuZXIoXCJTTk1cIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gZXZlbnQuZGV0YWlsLlNOTTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLlVVSUQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX25lc3QuU05NUHJvY2Vzc29yKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbWVzc2FnZSksIHsgVVVJRDogdGhpcy5fVVVJRCB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9uZXN0LlNOTVByb2Nlc3NvcihtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2JlYWNvbi5hZGRFdmVudExpc3RlbmVyKFwiUkNNXCIsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGV2ZW50LmRldGFpbC5DTTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLkJsb2JSZWxheSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5CbG9iUmVsYXkgPT0gXCJpZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9ibG9iUkxvb2t1cC5oYXMobWVzc2FnZS5Cb2R5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaCA9IHRoaXMuX2Jsb2JSTG9va3VwLmdldChtZXNzYWdlLkJvZHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kKHsgQmxvYlJlbGF5OiBcImhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBCb2R5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEhhc2g6IGgsIEluZm86IHRoaXMuX2Jsb2JJbmZvLmdldChoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIFttZXNzYWdlLlVVSURdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VuZEJsb2IoaCwgW21lc3NhZ2UuVVVJRF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1lc3NhZ2UuQmxvYlJlbGF5ID09IFwiaFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fYmxvYkluZm8uaGFzKG1lc3NhZ2UuQm9keS5IYXNoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYmxvYkluZm8uc2V0KG1lc3NhZ2UuQm9keS5IYXNoLCBtZXNzYWdlLkJvZHkuSW5mbyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgTUJIYW5kbGVyKHsgSGFzaDogbWVzc2FnZS5Cb2R5Lkhhc2ggfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZiA9IHRoaXMuX21lc3NhZ2VDYWxsYmFja01hcC5nZXQobWVzc2FnZS5UeXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoZiA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVmYXVsdE1lc3NhZ2VDYWxsYmFjayhtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGYobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fYmVhY29uLmFkZEV2ZW50TGlzdGVuZXIoXCJDTVVcIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gZXZlbnQuZGV0YWlsLkNNVTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLlVwZGF0ZSA9PSBcIk9wZW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25DaGFubmVsT3BlbmVkKG1lc3NhZ2UuUGVlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtZXNzYWdlLlVwZGF0ZSA9PSBcIkNsb3NlZFwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25DaGFubmVsQ2xvc2VkKG1lc3NhZ2UuUGVlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9uZXN0ID0gbmV3IG5lc3RfMS5OZXN0KHNvY2tldEFkZHIsIFJOTUhhbmRsZXIpO1xuICAgIH1cbiAgICBjb25uZWN0KG5ldHdvcmtJRCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0geyBUeXBlOiBpbnRlcmZhY2VzXzEuU2VuZGFibGVOZXN0TWVzc2FnZVR5cGUuSW5pdGlhbCwgT3RoZXI6IG5ldHdvcmtJRCB9O1xuICAgICAgICBjb25zdCB4ID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX25lc3QuaXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JlYWNvbi5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChcIlNOTVwiLCB7IGRldGFpbDogeyBTTk06IG1lc3NhZ2UgfSB9KSk7XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMTApO1xuICAgIH1cbiAgICByZWdpc3Rlck1lc3NhZ2UodHlwZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fbWVzc2FnZUNhbGxiYWNrTWFwLnNldCh0eXBlLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIHJlZ2lzdGVyRGVmYXVsdChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9kZWZhdWx0TWVzc2FnZUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIG9uY2hhbm5lbG9wZW4oY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fb25DaGFubmVsT3BlbmVkID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIG9uY2hhbm5lbGNsb3NlKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX29uQ2hhbm5lbENsb3NlZCA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICBzZW5kKGNtLCB1c2Vycykge1xuICAgICAgICBpZiAodXNlcnMgPT0gdW5kZWZpbmVkIHx8IHVzZXJzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIGNoYW5uZWxdIG9mIHRoaXMuX2FjdGl2ZUNoYW5uZWxzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuU0NNUHJvY2Vzc29yKGNtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdXNlciBvZiB1c2Vycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5uZWwgPSB0aGlzLl9hY3RpdmVDaGFubmVscy5nZXQodXNlcik7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5TQ01Qcm9jZXNzb3IoY20pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJlcXVlc3RCbG9iKGlkLCB1c2Vycykge1xuICAgICAgICB0aGlzLnNlbmQoeyBCbG9iUmVsYXk6IFwiaWRcIiwgQm9keTogaWQgfSwgdXNlcnMpO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2JlYWNvbi5hZGRFdmVudExpc3RlbmVyKFwiQk1DXCIsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5kZXRhaWwuSWQgPT0gaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYiA9IG5ldyBCbG9iKFtldmVudC5kZXRhaWwuQUJdLCB7IHR5cGU6IGV2ZW50LmRldGFpbC5UeXBlIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdW50QmxvYihpZCwgYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtb3VudEJsb2IoaWQsIGJsb2IpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IGJsb2IudHlwZTtcbiAgICAgICAgYmxvYi5hcnJheUJ1ZmZlcigpLnRoZW4oKGFiKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBoYXNoID0gaGFzaEFCKGFiKTtcbiAgICAgICAgICAgIHRoaXMuX2Jsb2JJbmZvLnNldChoYXNoLCB7IElkOiBpZCwgVHlwZTogdHlwZSB9KTtcbiAgICAgICAgICAgIHRoaXMuX21vdW50ZWRCbG9icy5zZXQoaGFzaCwgYWIpO1xuICAgICAgICAgICAgdGhpcy5fYmxvYlJMb29rdXAuc2V0KGlkLCBoYXNoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNlbmRCbG9iKGhhc2gsIHVzZXJzKSB7XG4gICAgICAgIGlmICh0aGlzLl9tb3VudGVkQmxvYnMuaGFzKGhhc2gpKSB7XG4gICAgICAgICAgICBjb25zdCBhYiA9IHRoaXMuX21vdW50ZWRCbG9icy5nZXQoaGFzaCk7XG4gICAgICAgICAgICBpZiAodXNlcnMgPT0gdW5kZWZpbmVkIHx8IHVzZXJzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCBjaGFubmVsXSBvZiB0aGlzLl9hY3RpdmVDaGFubmVscy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5SYXdNZXNzYWdlKGFiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHVzZXIgb2YgdXNlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuX2FjdGl2ZUNoYW5uZWxzLmdldCh1c2VyKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5SYXdNZXNzYWdlKGFiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlZlbG94ID0gVmVsb3g7XG5mdW5jdGlvbiBoYXNoQUIoYWIpIHtcbiAgICByZXR1cm4gU3BhcmtNRDUuQXJyYXlCdWZmZXIuaGFzaChhYiwgdHJ1ZSk7XG59XG5leHBvcnRzLmhhc2hBQiA9IGhhc2hBQjtcbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIiLCIvLyBzdGFydHVwXG4vLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8vIFRoaXMgZW50cnkgbW9kdWxlIGlzIHJlZmVyZW5jZWQgYnkgb3RoZXIgbW9kdWxlcyBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkXG52YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL2xpYi93ZWIvdmVsb3gudHNcIik7XG4iLCIiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n\n//# sourceURL=webpack://demo/./node_modules/velox-songbird/build/velox-bundle.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./demo-dfs/lib/main.js");
/******/ 	
/******/ })()
;